#!/bin/sh
#
# Description:  Manages a PostgreSQL Server as an OCF High-Availability
#               resource
#
# Authors:      Serge Dubrouski (sergeyfd@gmail.com) -- original RA
#               Florian Haas (florian@linbit.com) -- makeover
#               Takatoshi MATSUO (matsuo.tak@gmail.com) -- support replication
#
# Copyright:    2006-2012 Serge Dubrouski <sergeyfd@gmail.com>
#                         and other Linux-HA contributors
# License:      GNU General Public License (GPL)
#
###############################################################################
# Initialization:

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

#
# Get PostgreSQL Configuration parameter
#
get_pgsql_param() {
    local param_name

    param_name=$1
    perl_code="if (/^\s*$param_name[\s=]+\s*(.*)$/) {
       \$dir=\$1;
       \$dir =~ s/\s*\#.*//;
       \$dir =~ s/^'(\S*)'/\$1/;
       print \$dir;}"

    perl -ne "$perl_code" < $OCF_RESKEY_config
}

# Defaults
OCF_RESKEY_pgctl_default=/usr/bin/pg_ctl
OCF_RESKEY_psql_default=/usr/bin/psql
OCF_RESKEY_pgdata_default=/var/lib/pgsql/data
OCF_RESKEY_pgdba_default=postgres
OCF_RESKEY_pghost_default=""
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_start_opt_default=""
OCF_RESKEY_pgdb_default=template1
OCF_RESKEY_logfile_default=/dev/null
OCF_RESKEY_stop_escalate_default=30
OCF_RESKEY_monitor_user_default=""
OCF_RESKEY_monitor_password_default=""
OCF_RESKEY_monitor_sql_default="select now();"
OCF_RESKEY_check_wal_receiver_default="false"
# Defaults for replication
OCF_RESKEY_rep_mode_default=none
OCF_RESKEY_node_list_default=""
OCF_RESKEY_restore_command_default=""
OCF_RESKEY_archive_cleanup_command_default=""
OCF_RESKEY_recovery_end_command_default=""
OCF_RESKEY_master_ip_default=""
OCF_RESKEY_repuser_default="postgres"
OCF_RESKEY_primary_conninfo_opt_default=""
OCF_RESKEY_restart_on_promote_default="false"
OCF_RESKEY_tmpdir_default="/var/lib/pgsql/tmp"
OCF_RESKEY_xlog_check_count_default="3"
OCF_RESKEY_crm_attr_timeout_default="5"
OCF_RESKEY_stop_escalate_in_slave_default=30

: ${OCF_RESKEY_pgctl=${OCF_RESKEY_pgctl_default}}
: ${OCF_RESKEY_psql=${OCF_RESKEY_psql_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgdba=${OCF_RESKEY_pgdba_default}}
: ${OCF_RESKEY_pghost=${OCF_RESKEY_pghost_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_config=${OCF_RESKEY_pgdata}/postgresql.conf}
: ${OCF_RESKEY_start_opt=${OCF_RESKEY_start_opt_default}}
: ${OCF_RESKEY_pgdb=${OCF_RESKEY_pgdb_default}}
: ${OCF_RESKEY_logfile=${OCF_RESKEY_logfile_default}}
: ${OCF_RESKEY_stop_escalate=${OCF_RESKEY_stop_escalate_default}}
: ${OCF_RESKEY_monitor_user=${OCF_RESKEY_monitor_user_default}}
: ${OCF_RESKEY_monitor_password=${OCF_RESKEY_monitor_password_default}}
: ${OCF_RESKEY_monitor_sql=${OCF_RESKEY_monitor_sql_default}}
: ${OCF_RESKEY_check_wal_receiver=${OCF_RESKEY_check_wal_receiver_default}}

# for replication
: ${OCF_RESKEY_rep_mode=${OCF_RESKEY_rep_mode_default}}
: ${OCF_RESKEY_node_list=${OCF_RESKEY_node_list_default}}
: ${OCF_RESKEY_restore_command=${OCF_RESKEY_restore_command_default}}
: ${OCF_RESKEY_archive_cleanup_command=${OCF_RESKEY_archive_cleanup_command_default}}
: ${OCF_RESKEY_recovery_end_command=${OCF_RESKEY_recovery_end_command_default}}
: ${OCF_RESKEY_master_ip=${OCF_RESKEY_master_ip_default}}
: ${OCF_RESKEY_repuser=${OCF_RESKEY_repuser_default}}
: ${OCF_RESKEY_primary_conninfo_opt=${OCF_RESKEY_primary_conninfo_opt_default}}
: ${OCF_RESKEY_restart_on_promote=${OCF_RESKEY_restart_on_promote_default}}
: ${OCF_RESKEY_tmpdir=${OCF_RESKEY_tmpdir_default}}
: ${OCF_RESKEY_xlog_check_count=${OCF_RESKEY_xlog_check_count_default}}
: ${OCF_RESKEY_crm_attr_timeout=${OCF_RESKEY_crm_attr_timeout_default}}
: ${OCF_RESKEY_stop_escalate_in_slave=${OCF_RESKEY_stop_escalate_in_slave_default}}

usage() {
    cat <<EOF
        usage: $0 start|stop|status|monitor|promote|demote|notify|meta-data|validate-all|methods

        $0 manages a PostgreSQL Server as an HA resource.

        The 'start' operation starts the PostgreSQL server.
        The 'stop' operation stops the PostgreSQL server.
        The 'status' operation reports whether the PostgreSQL is up.
        The 'monitor' operation reports whether the PostgreSQL is running.
        The 'promote' operation promotes the PostgreSQL server.
        The 'demote' operation demotes the PostgreSQL server.
        The 'validate-all' operation reports whether the parameters are valid.
        The 'methods' operation reports on the methods $0 supports.
EOF
  return $OCF_ERR_ARGS
}

meta_data() {
    cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsql">
<version>1.0</version>

<longdesc lang="en">
Resource script for PostgreSQL. It manages a PostgreSQL as an HA resource.
</longdesc>
<shortdesc lang="en">Manages a PostgreSQL database instance</shortdesc>

<parameters>
<parameter name="pgctl" unique="0" required="0">
<longdesc lang="en">
Path to pg_ctl command.
</longdesc>
<shortdesc lang="en">pgctl</shortdesc>
<content type="string" default="${OCF_RESKEY_pgctl_default}" />
</parameter>

<parameter name="start_opt" unique="0" required="0">
<longdesc lang="en">
Start options (-o start_opt in pg_ctl). "-i -p 5432" for example.
</longdesc>
<shortdesc lang="en">start_opt</shortdesc>
<content type="string" default="${OCF_RESKEY_start_opt_default}" />

</parameter>
<parameter name="ctl_opt" unique="0" required="0">
<longdesc lang="en">
Additional pg_ctl options (-w, -W etc..).
</longdesc>
<shortdesc lang="en">ctl_opt</shortdesc>
<content type="string" default="${OCF_RESKEY_ctl_opt_default}" />
</parameter>

<parameter name="psql" unique="0" required="0">
<longdesc lang="en">
Path to psql command.
</longdesc>
<shortdesc lang="en">psql</shortdesc>
<content type="string" default="${OCF_RESKEY_psql_default}" />
</parameter>

<parameter name="pgdata" unique="0" required="0">
<longdesc lang="en">
Path to PostgreSQL data directory.
</longdesc>
<shortdesc lang="en">pgdata</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdata_default}" />
</parameter>

<parameter name="pgdba" unique="0" required="0">
<longdesc lang="en">
User that owns PostgreSQL.
</longdesc>
<shortdesc lang="en">pgdba</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdba_default}" />
</parameter>

<parameter name="pghost" unique="0" required="0">
<longdesc lang="en">
Hostname/IP address where PostgreSQL is listening
</longdesc>
<shortdesc lang="en">pghost</shortdesc>
<content type="string" default="${OCF_RESKEY_pghost_default}" />
</parameter>

<parameter name="pgport" unique="0" required="0">
<longdesc lang="en">
Port where PostgreSQL is listening
</longdesc>
<shortdesc lang="en">pgport</shortdesc>
<content type="integer" default="${OCF_RESKEY_pgport_default}" />
</parameter>

<parameter name="monitor_user" unique="0" required="0">
<longdesc lang="en">
PostgreSQL user that pgsql RA will user for monitor operations. If it's not set
pgdba user will be used.
</longdesc>
<shortdesc lang="en">monitor_user</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_user_default}" />
</parameter>

<parameter name="monitor_password" unique="0" required="0">
<longdesc lang="en">
Password for monitor user.
</longdesc>
<shortdesc lang="en">monitor_password</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_password_default}" />
</parameter>

<parameter name="monitor_sql" unique="0" required="0">
<longdesc lang="en">
SQL script that will be used for monitor operations.
</longdesc>
<shortdesc lang="en">monitor_sql</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_sql_default}" />
</parameter>

<parameter name="config" unique="0" required="0">
<longdesc lang="en">
Path to the PostgreSQL configuration file for the instance.
</longdesc>
<shortdesc lang="en">Configuration file</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdata}/postgresql.conf" />
</parameter>

<parameter name="pgdb" unique="0" required="0">
<longdesc lang="en">
Database that will be used for monitoring.
</longdesc>
<shortdesc lang="en">pgdb</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdb_default}" />
</parameter>

<parameter name="logfile" unique="0" required="0">
<longdesc lang="en">
Path to PostgreSQL server log output file.
</longdesc>
<shortdesc lang="en">logfile</shortdesc>
<content type="string" default="${OCF_RESKEY_logfile_default}" />
</parameter>

<parameter name="socketdir" unique="0" required="0">
<longdesc lang="en">
Unix socket directory for PostgreSQL
</longdesc>
<shortdesc lang="en">socketdir</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="stop_escalate" unique="0" required="0">
<longdesc lang="en">
Number of shutdown retries (using -m fast) before resorting to -m immediate
</longdesc>
<shortdesc lang="en">stop escalation</shortdesc>
<content type="integer" default="${OCF_RESKEY_stop_escalate_default}" />
</parameter>

<parameter name="rep_mode" unique="0" required="0">
<longdesc lang="en">
Replication mode may be set to "async" or "sync" or "slave".
They require PostgreSQL 9.1 or later.
Once set, "async" and "sync" require node_list, master_ip, and
restore_command parameters,as well as configuring PostgreSQL
for replication (in postgresql.conf and pg_hba.conf).

"slave" means that RA only makes recovery.conf before starting
to connect to primary which is running somewhere.
It dosen't need master/slave setting.
It requires master_ip restore_command parameters.
</longdesc>
<shortdesc lang="en">rep_mode</shortdesc>
<content type="string" default="${OCF_RESKEY_rep_mode_default}" />
</parameter>

<parameter name="node_list" unique="0" required="0">
<longdesc lang="en">
All node names. Please separate each node name with a space.
This is required for replication.
</longdesc>
<shortdesc lang="en">node list</shortdesc>
<content type="string" default="${OCF_RESKEY_node_list_default}" />
</parameter>

<parameter name="restore_command" unique="0" required="0">
<longdesc lang="en">
restore_command for recovery.conf.
This is required for replication.
</longdesc>
<shortdesc lang="en">restore_command</shortdesc>
<content type="string" default="${OCF_RESKEY_restore_command_default}" />
</parameter>

<parameter name="archive_cleanup_command" unique="0" required="0">
<longdesc lang="en">
archive_cleanup_command for recovery.conf.
This is used for replication and is optional.
</longdesc>
<shortdesc lang="en">archive_cleanup_command</shortdesc>
<content type="string" default="${OCF_RESKEY_archive_cleanup_command_default}" />
</parameter>

<parameter name="recovery_end_command" unique="0" required="0">
<longdesc lang="en">
recovery_end_command for recovery.conf.
This is used for replication and is optional.
</longdesc>
<shortdesc lang="en">recovery_end_command</shortdesc>
<content type="string" default="${OCF_RESKEY_recovery_end_command_default}" />
</parameter>

<parameter name="master_ip" unique="0" required="0">
<longdesc lang="en">
Master's floating IP address to be connected from hot standby.
This parameter is used for "primary_conninfo" in recovery.conf.
This is required for replication.
</longdesc>
<shortdesc lang="en">master ip</shortdesc>
<content type="string" default="${OCF_RESKEY_master_ip_default}" />
</parameter>

<parameter name="repuser" unique="0" required="0">
<longdesc lang="en">
User used to connect to the master server.
This parameter is used for "primary_conninfo" in recovery.conf.
This is required for replication.
</longdesc>
<shortdesc lang="en">repuser</shortdesc>
<content type="string" default="${OCF_RESKEY_repuser_default}" />
</parameter>

<parameter name="primary_conninfo_opt" unique="0" required="0">
<longdesc lang="en">
primary_conninfo options of recovery.conf except host, port, user and application_name.
This is optional for replication.
</longdesc>
<shortdesc lang="en">primary_conninfo_opt</shortdesc>
<content type="string" default="${OCF_RESKEY_primary_conninfo_opt_default}" />
</parameter>

<parameter name="restart_on_promote" unique="0" required="0">
<longdesc lang="en">
If this is true, RA deletes recovery.conf and restarts PostgreSQL
on promote to keep Timeline ID. It probably makes fail-over slower.
It's recommended to set on-fail of promote up as fence.
This is optional for replication.
</longdesc>
<shortdesc lang="en">restart_on_promote</shortdesc>
<content type="boolean" default="${OCF_RESKEY_restart_on_promote_default}" />
</parameter>

<parameter name="tmpdir" unique="0" required="0">
<longdesc lang="en">
Path to temporary directory.
This is optional for replication.
</longdesc>
<shortdesc lang="en">tmpdir</shortdesc>
<content type="string" default="${OCF_RESKEY_tmpdir_default}" />
</parameter>

<parameter name="xlog_check_count" unique="0" required="0">
<longdesc lang="en">
Number of checks of xlog on monitor before promote.
This is optional for replication.
</longdesc>
<shortdesc lang="en">xlog check count</shortdesc>
<content type="integer" default="${OCF_RESKEY_check_count_default}" />
</parameter>

<parameter name="crm_attr_timeout" unique="0" required="0">
<longdesc lang="en">
The timeout of crm_attribute forever update command.
Default value is 5 seconds.
This is optional for replication.
</longdesc>
<shortdesc lang="en">The timeout of crm_attribute forever update command.</shortdesc>
<content type="integer" default="${OCF_RESKEY_crm_attr_timeout_default}" />
</parameter>

<parameter name="stop_escalate_in_slave" unique="0" required="0">
<longdesc lang="en">
Number of shutdown retries (using -m fast) before resorting to -m immediate
in slave state.
This is optional for replication.
</longdesc>
<shortdesc lang="en">stop escalation_in_slave</shortdesc>
<content type="integer" default="${OCF_RESKEY_stop_escalate_in_slave_default}" />
</parameter>

<parameter name="check_wal_receiver" unique="0" required="0">
<longdesc lang="en">
If this is true, RA checks wal_receiver process on monitor
and notifies its status using "(resource name)-receiver-status" attribute.
It's useful for checking whether PostgreSQL (hot standby) connects to primary.
The attribute shows status as "normal" or "ERROR".
</longdesc>
<shortdesc lang="en">check_wal_receiver</shortdesc>
<content type="boolean" default="${OCF_RESKEY_check_wal_receiver_default}" />
</parameter>
</parameters>

<actions>
<action name="start" timeout="120" />
<action name="stop" timeout="120" />
<action name="status" timeout="60" />
<action name="monitor" depth="0" timeout="30" interval="30"/>
<action name="monitor" depth="0" timeout="30" interval="29" role="Master" />
<action name="promote" timeout="120" />
<action name="demote" timeout="120" />
<action name="notify"   timeout="90" />
<action name="meta-data" timeout="5" />
<action name="validate-all" timeout="5" />
<action name="methods" timeout="5" />
</actions>
</resource-agent>
EOF
}


#
#   Run the given command in the Resource owner environment...
#
runasowner() {
    local quietrun=""
    local loglevel="-err"
    local var

    for var in 1 2
    do
        case "$1" in
            "-q")
                quietrun="-q"
                shift 1;;
            "warn"|"err")
                loglevel="-$1"
                shift 1;;
            *)
                ;;
        esac
    done

    ocf_run $quietrun $loglevel su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; $*"
}

#
#       Shell escape
#
escape_string() {
    echo "$*" | sed -e "s/'/'\\\\''/g"
}


#
# methods: What methods/operations do we support?
#

pgsql_methods() {
    cat <<EOF
    start
    stop
    status
    monitor
    promote
    demote
    notify
    methods
    meta-data
    validate-all
EOF
}


#pgsql_real_start: Starts PostgreSQL
pgsql_real_start() {
    local pgctl_options
    local postgres_options
    local rc

    if pgsql_status; then
        # PostgreSQLがすでに起動している場合の処理
        ocf_log info "PostgreSQL is already running. PID=`cat $PIDFILE`"
        if is_replication; then
            # レプリケーション使用時は、RAからPostgreSQLが起動されていない場合、
            # 属性値等が正常に初期化されていない可能性があるので、起動NGとする
            return $OCF_ERR_GENERIC
        else
            return $OCF_SUCCESS
        fi
    fi

    # Remove postmaster.pid if it exists
    rm -f $PIDFILE

    # Remove backup_label if it exists
    # レプリケーション使用時、データの整合性を保つためにバックアップラベルは削除しない(だったかな?)
    if [ -f $BACKUPLABEL ] && ! is_replication; then
        ocf_log info "Removing $BACKUPLABEL. The previous backup might have failed."
        rm -f $BACKUPLABEL
    fi

    # Check if we need to create a log file
    if ! check_log_file $OCF_RESKEY_logfile
    then
        ocf_log err "PostgreSQL can't write to the log file: $OCF_RESKEY_logfile"
        return $OCF_ERR_PERM
    fi

    # Check socket directory
    if [ -n "$OCF_RESKEY_socketdir" ]
    then
        check_socket_dir
    fi

    # rep_mode=slaveの時、pgsql_replication_start() を通らないためここで作成
    # TODO コードが冗長なので、rep_mode=sync, asyncの場合もここで作るようにすればGoodかも。
    if [ "$OCF_RESKEY_rep_mode" = "slave" ]; then
        rm -f $RECOVERY_CONF
        make_recovery_conf || return $OCF_ERR_GENERIC
    fi

    # PostgreSQL起動時に使用するpg_ctlコマンドのオプションを作成
    # Set options passed to pg_ctl
    pgctl_options="$OCF_RESKEY_ctl_opt -D $OCF_RESKEY_pgdata -l $OCF_RESKEY_logfile"

    # Set options passed to the PostgreSQL server process
    postgres_options="-c config_file=${OCF_RESKEY_config}"

    if [ -n "$OCF_RESKEY_pghost" ]; then
        postgres_options="$postgres_options -h $OCF_RESKEY_pghost"
    fi
    if [ -n "$OCF_RESKEY_start_opt" ]; then
        postgres_options="$postgres_options $OCF_RESKEY_start_opt"
    fi

    # Tack pass-through options onto pg_ctl options
    pgctl_options="$pgctl_options -o '$postgres_options'"

    # Invoke pg_ctl
    # 環境変数PGUSERやPGPASSWORは、monitor時に必要となるため共通処理としてすでに下の方で
    # セットされているが、起動時にセットしてしまうと、レプリケーション接続時にもこれらの
    # 環境変数が使用されてしまい、ユーザ指定のレプリケーション用ユーザ(repuser)や、
    # repuserのパスワード設定(.pgpass ファイル)が無視されてしまうため、unsetしている
    runasowner "unset PGUSER; unset PGPASSWORD; $OCF_RESKEY_pgctl $pgctl_options start"

    if [ $? -eq 0 ]; then
        # Probably started.....
        ocf_log info "PostgreSQL start command sent."
    else
        ocf_log err "Can't start PostgreSQL."
        return $OCF_ERR_GENERIC
    fi

    # 起動するまで待つ
    while :
    do
        pgsql_real_monitor warn
        rc=$?
        if [ $rc -eq $OCF_SUCCESS -o $rc -eq $OCF_RUNNING_MASTER ]; then
            break;
        fi
        sleep 1
        ocf_log debug "PostgreSQL still hasn't started yet. Waiting..."
    done

    ocf_log info "PostgreSQL is started."
    return $rc
}

pgsql_replication_start() {
    local rc

    # initializing for replication
    # pgsql-status 属性値をSTOPに初期化する。
    change_pgsql_status "$NODENAME" "STOP"

    # pgsql-master-baseline 属性値を削除
    delete_master_baseline

    # 自分のデータの状態は不明のためpromoteされないようにする。crm_master コマンド失敗時はリトライ。
    exec_with_retry 0 $CRM_MASTER -v $CAN_NOT_PROMOTE

    # 一時的なファイルが残っている可能性があるので削除
    rm -f ${XLOG_NOTE_FILE}.* $REP_MODE_CONF $RECOVERY_CONF

    # Slaveで起動するためにrecovery.confを作成し、pgsql-xlog-replay-loc 属性を削除し、
    # postgresql.confの設定を非同期にする
    if ! make_recovery_conf || ! delete_xlog_location || ! set_async_mode_all; then
        return $OCF_ERR_GENERIC
    fi

    # ロックファイルがあると、自分のデータに不整合が発生している可能性があるため起動NGとする
    if [ -f $PGSQL_LOCK ]; then
        ocf_log err "My data may be inconsistent. You have to remove $PGSQL_LOCK file to force start."
        return $OCF_ERR_GENERIC
    fi

    # start
    pgsql_real_start
    if [ $? -ne $OCF_SUCCESS ]; then
        return $OCF_ERR_GENERIC
    fi

    # 起動成功時は自分のpgsql-statusをHS:aloneに変更する
    change_pgsql_status "$NODENAME" "HS:alone"
    return $OCF_SUCCESS
}

#pgsql_start: pgsql_real_start() wrapper for replication
pgsql_start() {
    # rep_modeパラメータがsyncまたはasyncの場合は、Master/Slave制御用の関数
    # pgsql_replication_start を呼び出す。
    if ! is_replication; then
        pgsql_real_start
        return $?
    else
        pgsql_replication_start
        return $?
    fi
}

#pgsql_promote: Promote PostgreSQL
pgsql_promote() {
    local target
    local rc

    # レプリケーション構成時以外では呼び出されるはずがないためエラーに。
    if ! is_replication; then
        ocf_log err "Not in a replication mode."
        return $OCF_ERR_CONFIGURED
    fi
    rm -f ${XLOG_NOTE_FILE}.*

    # promote対象ノードがNODE_LISTに入っていない場合も想定外のためエラーに。
    for target in $NODE_LIST; do
        [ "$target" = "$NODENAME" ] && continue
        change_data_status "$target" "DISCONNECT"
        change_master_score "$target" "$CAN_NOT_PROMOTE"
    done

    # ロックファイル作成
    ocf_log info "Creating $PGSQL_LOCK."
    touch $PGSQL_LOCK

    # promote直前のデータの位置をpgsql-master-baselineとして見せる
    # 昔のRAの実装では、このデータの位置を利用していたが、現在の実装では
    # 3ノード以上でしか利用されない属性値。
    # 障害発生時の解析に少しは役に立つかも？
    show_master_baseline

    if ocf_is_true ${OCF_RESKEY_restart_on_promote}; then
        # restart_on_promote=trueの場合、promoteではなく再起動する
        # ※ 主にTimelineIDの増加を防ぐのが目的だが、TimelineIDの本来の目的を
        #    無視しているため、データの安全性は落ちそう・・・
        # コミュニティからの提案で実装。

        ocf_log info "Restarting PostgreSQL instead of promote."
        #stop : this function returns $OCF_SUCCESS only.
        pgsql_real_stop slave
        rm -f $RECOVERY_CONF
        pgsql_real_start
        rc=$?
        if [ $rc -ne $OCF_RUNNING_MASTER ]; then
            ocf_log err "Can't start PostgreSQL as primary on promote."
            if [ $rc -ne $OCF_SUCCESS ]; then
                change_pgsql_status "$NODENAME" "STOP"
            fi
            return $OCF_ERR_GENERIC
        fi
    else
        # promote実行
        runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata promote"
        if [ $? -eq 0 ]; then
            ocf_log info "PostgreSQL promote command sent."
        else
            ocf_log err "Can't promote PostgreSQL."
            return $OCF_ERR_GENERIC
        fi

        # promoteが成功するまで待つ
        while :
        do
            # 自分がMasterになったかどうかの判断には、monitor時の関数を利用
            pgsql_real_monitor warn
            rc=$?
            if [ $rc -eq $OCF_RUNNING_MASTER ]; then
                break;
            elif [ $rc -eq $OCF_ERR_GENERIC ]; then
                ocf_log err "Can't promote PostgreSQL."
                return $rc
            fi
            sleep 1
            ocf_log debug "PostgreSQL still hasn't promoted yet. Waiting..."
        done
        ocf_log info "PostgreSQL is promoted."
    fi

    # promote成功時は、pgsql-data-status=LATEST, pgsql-status=PRIに変更し、
    # マスタスコアも1000に上げる。
    change_data_status "$NODENAME" "LATEST"
    exec_with_retry 0 $CRM_MASTER -v $PROMOTE_ME
    change_pgsql_status "$NODENAME" "PRI"
    return $OCF_SUCCESS
}

#pgsql_demote: Demote PostgreSQL
pgsql_demote() {
    local rc

    if ! is_replication; then
        ocf_log err "Not in a replication mode."
        return $OCF_ERR_CONFIGURED
    fi

    # 念のためマスタスコアは-INFINITYへ変更する。
    exec_with_retry 0 $CRM_MASTER -v $CAN_NOT_PROMOTE
    delete_master_baseline

    if ! pgsql_status; then
        ocf_log info "PostgreSQL is already stopped on demote."
    else
        ocf_log info "Stopping PostgreSQL on demote."

        # PostgreSQLはdemoteできないため、demote時にPostgreSQLは停止する。
        # Master故障時は、demote直後にstopが呼ばれるが、demoteのみが実行された場合
        # demote後にSlaveとして留まり、SlaveのmonitorでNGとなり、
        # フェイルカウントが上がることで結局stopが呼ばれるはず。
        pgsql_real_stop master
        rc=$?
        if [ "$rc" -ne "$OCF_SUCCESS" ]; then
            change_pgsql_status "$NODENAME" "UNKNOWN"
            return $rc
        fi
    fi

    # 停止成功時は、pgsql-status=STOPに変更
    change_pgsql_status "$NODENAME" "STOP"

    return $OCF_SUCCESS
}

# PostgreSQLを停止する処理。
# レプリケーション構成時は、demoteでもstopでもこの関数が呼ばれるが、
# demote時は第一引数にmasterが、stop時はslaveが渡される。
#pgsql_real_stop: Stop PostgreSQL
pgsql_real_stop() {
    local rc
    local count
    local stop_escalate

    if ocf_is_true ${OCF_RESKEY_check_wal_receiver}; then
        attrd_updater -n "$PGSQL_WAL_RECEIVER_STATUS_ATTR" -D -q
    fi

    if ! pgsql_status
    then
        #Already stopped
        return $OCF_SUCCESS
    fi

    stop_escalate=$OCF_RESKEY_stop_escalate
    if [ "$1" = "slave" ]; then
        # レプリケーション構成時、slaveのstopの場合は、stop_escalate_in_slaveを使用する
        stop_escalate="$OCF_RESKEY_stop_escalate_in_slave"
    fi

    # Stop PostgreSQL, do not wait for clients to disconnect
    if [ $stop_escalate -gt 0 ]; then
            # stop_escalate が 1以上の場合はfast shutdownを実行する。
            # 0の場合は、下の処理にスキップするため、いきなりimmediate shutdownが実行される
            runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata stop -m fast"
    fi

    # stop_escalate で指定した秒数、シャットダウンされるのを待つ
    # stop waiting
    count=0
    while [ $count -lt $stop_escalate ]
    do
        if ! pgsql_status
        then
            #PostgreSQL stopped
            break;
        fi
        count=`expr $count + 1`
        sleep 1
    done

    # PostgreSQLが停止していない場合、immediate shutdownに移行する
    if pgsql_status
    then
        #PostgreSQL is still up. Use another shutdown mode.
        ocf_log info "PostgreSQL failed to stop after ${OCF_RESKEY_stop_escalate}s using -m fast. Trying -m immediate..."
        runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata stop -m immediate"
    fi

    # PostgreSQLが停止するまで永遠に待つ。
    # ※ 停止しない場合でも、実際はPacemaker側のstop timeoutが発生するため、そこで処理は強制終了される
    while :
    do
        pgsql_real_monitor
        rc=$?
        if [ $rc -eq $OCF_NOT_RUNNING ]; then
            # An unnecessary debug log is prevented.
            break;
        fi
        sleep 1
        ocf_log debug "PostgreSQL still hasn't stopped yet. Waiting..."
    done

    # Remove postmaster.pid if it exists
    rm -f $PIDFILE

    # 自分がMasterで、かつ他にSlaveが存在しない場合、自分のデータが最新のはずなので、
    # ロックファイルを削除する。(ここに入るのはdemote時の停止処理の場合のみ)
    if  [ "$1" = "master" -a "$OCF_RESKEY_CRM_meta_notify_slave_uname" = " " ]; then
        ocf_log info "Removing $PGSQL_LOCK."
        rm -f $PGSQL_LOCK
    fi
    return $OCF_SUCCESS
}

pgsql_replication_stop() {
    local rc

    # 念のためマスタスコアを-INFINITYへ変更
    exec_with_retry 5 $CRM_MASTER -v $CAN_NOT_PROMOTE
    $CRM_MASTER -v $CAN_NOT_PROMOTE

    # pgsql-xlog-loc 属性が残っている場合があるので削除
    delete_xlog_location

    # PID ファイルチェックし、無い場合は停止済みと判断
    if ! pgsql_status
    then
        ocf_log info "PostgreSQL is already stopped."
        change_pgsql_status "$NODENAME" "STOP"
        return $OCF_SUCCESS
    fi

    # pgsql_real_stop()は、demote時も呼ばれるが、stop時と区別で区別する
    # ために引数にslaveを渡す
    pgsql_real_stop slave
    rc=$?
    if [ $rc -ne $OCF_SUCCESS ]; then
        # 停止失敗時はPostgreSQLの状態が不明のため、pgsql-status は UNKNOWN 
        # とする
        change_pgsql_status "$NODENAME" "UNKNOWN"
        return $rc
    fi

    # 停止成功時は、pgsql-status=STOP に変更
    change_pgsql_status "$NODENAME" "STOP"

    # 停止成功後の後処理として、同期モードは全て非同期に戻し、
    # 不要な属性(pgsql-master-baseline)が残っている可能性があるため
    # 削除する
    set_async_mode_all
    delete_master_baseline

    return $OCF_SUCCESS
}

#pgsql_stop: pgsql_real_stop() wrapper for replication
pgsql_stop() {
    if ! is_replication; then
        pgsql_real_stop
        return $?
    else
        pgsql_replication_stop
        return $?
    fi
}

#
# pgsql_status: is PostgreSQL up?
#

pgsql_status() {
     if [ -f $PIDFILE ]
     then
         PID=`head -n 1 $PIDFILE`
         runasowner "kill -s 0 $PID >/dev/null 2>&1"
         return $?
     fi

     # No PID file
     false
}

# wal reciver process の状態を属性値として表示するための関数 (あまり役立たたない)
pgsql_wal_receiver_status() {
    local PID
    local receiver_parent_pids

    PID=`head -n 1 $PIDFILE`
    receiver_parent_pids=`ps -ef | tr -s " " | grep "[w]al receiver process" | cut -d " " -f 3`
    if echo "$receiver_parent_pids" | grep -q -w "$PID" ; then
        attrd_updater -n "$PGSQL_WAL_RECEIVER_STATUS_ATTR" -v "normal" -q
        return 0
    fi
    attrd_updater -n "$PGSQL_WAL_RECEIVER_STATUS_ATTR" -v "ERROR" -q
    ocf_log warn "wal receiver process is not running"
    return 1
}

#
# pgsql_real_monitor
#

pgsql_real_monitor() {
    local loglevel
    local rc
    local output

    # Set the log level of the error message
    loglevel=${1:-err}

    if ! pgsql_status
    then
        ocf_log info "PostgreSQL is down"
        return $OCF_NOT_RUNNING
    fi

    if ocf_is_true ${OCF_RESKEY_check_wal_receiver}; then
        # wal_receiverプロセスがいるかどうかを確認し、状態を属性値として
        # 見せる。レプリケーション接続が切れていてもwal_receiverプロセスが
        # 存在することがわかったため、この機能はあまり意味がないことが判明
        pgsql_wal_receiver_status
    fi

    if is_replication; then
        # レプリケーション使用時のPostgreSQLの生死確認処理。
        # select pg_is_in_recovery() を投げて、自分がMasterかSlaveかを確認する
        #Check replication state
        output=`su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; \
                $OCF_RESKEY_psql $psql_options -U $OCF_RESKEY_pgdba \
                -Atc \"${CHECK_MS_SQL}\""`
        rc=$?
        if [ $rc -ne  0 ]; then
            report_psql_error $rc $loglevel "Can't get PostgreSQL recovery status."
            return $OCF_ERR_GENERIC
        fi

        # pg_is_in_recovery()の結果がtならSlave, fならMasterと判断
        case "$output" in
            f)  ocf_log debug "PostgreSQL is running as a primary."

                # ユーザ指定の監視用SQL(monitor_sql)がセットされていて、
                # さらに自分がMasterの場合は、monitor_sqlを下で実行する
                if [ "$OCF_RESKEY_monitor_sql" = "$OCF_RESKEY_monitor_sql_default" ]; then
                    return $OCF_RUNNING_MASTER
                fi
                ;;

            t)  ocf_log debug "PostgreSQL is running as a hot standby."
                # Slaveの場合はmonitor_sqlは実行しない。つまりSlaveの生死確認は
                # pg_is_in_recovery()だけ。
                return $OCF_SUCCESS;;

            *)  ocf_log err "$CHECK_MS_SQL output is $output"
                return $OCF_ERR_GENERIC;;
        esac
    fi

    # Act-Sby構成時はここで生死確認を実施。
    # レプリケーション使用時で monitor_sql がセットされている場合もこれが実行される
    OCF_RESKEY_monitor_sql=`escape_string "$OCF_RESKEY_monitor_sql"`
    runasowner -q $loglevel "$OCF_RESKEY_psql $psql_options \
                  -c '$OCF_RESKEY_monitor_sql'"
    rc=$?
    if [ $rc -ne  0 ]; then
        report_psql_error $rc $loglevel "PostgreSQL $OCF_RESKEY_pgdb isn't running."
        return $OCF_ERR_GENERIC
    fi

    if is_replication; then
        # レプリケーション使用時にここに入れるのは、Masterの時だけのため、
        # OCF_RUNNING_MASTERを返す
        return $OCF_RUNNING_MASTER
    fi

    # Act-Sby構成時は通常の成功値を返す
    return $OCF_SUCCESS
}

# レプリケーション使用時、monitorでMaster/Slaveの制御を行う関数
pgsql_replication_monitor() {
    local rc

    rc=$1
    # pgsql_real_monitor の値が異常値の場合はそのまま異常として返す
    if [ $rc -ne $OCF_SUCCESS -a $rc -ne "$OCF_RUNNING_MASTER" ]; then
        return $rc
    fi
    # If I am Master
    if [ $rc -eq $OCF_RUNNING_MASTER ]; then
        # 自分がMasterの場合、pgsql-statusやpgsql-data-statusを
        # 適切に設定する。
        # なお、monitorの度に設定値を上書きするのは無駄な動作なため、
        # change_xxx_status 関数内では、現在の値が指定された値と異なる場合のみ
        # 属性値をアップデートするような実装になっている
        change_data_status "$NODENAME" "LATEST"
        change_pgsql_status "$NODENAME" "PRI"

        # 自分がMasterの場合、Slaveの状態を確認し制御するための関数を呼び出す。
        # 具体的には、slaveが繋がっているか、繋がっているときは、asyncなのかsyncなのか、
        # async の場合は sync に変更する必要があるのか、といった判断を行い、
        # 実際にsync, async を切り替えたり、Slave の pgsql-statusやpgsql-data-statusを
        # 変更している。
        control_slave_status || return $OCF_ERR_GENERIC
        if [ "$RE_CONTROL_SLAVE" = "true" ]; then
            sleep 2
            ocf_log info "re-controlling slave status."
            RE_CONTROL_SLAVE="none"
            control_slave_status || return $OCF_ERR_GENERIC
        fi
        return $rc
    fi

    # ここからは自分がSlaveの場合の処理

    # I can't get master node name from $OCF_RESKEY_CRM_meta_notify_master_uname on monitor,
    # so I will get master node name using crm_mon -n
    print_crm_mon | tr -d "\t" | tr -d " " | grep -q "^${RESOURCE_NAME}[(:].*[):]Master"
    if [ $? -ne 0 ] ; then
        # If I am Slave and Master is not exist
        ocf_log info "Master does not exist."

        # Masterがいない場合、自分が繋がる先がないはずなので、自分のpgsql-statusをHS:aloneにする
        change_pgsql_status "$NODENAME" "HS:alone"

        # 自分がMasterになれる権利を持っているかどうかを確認する関数
        have_master_right
        if [ $? -eq 0 ]; then
            rm -f ${XLOG_NOTE_FILE}.*
        fi
    else
        output=`exec_with_retry 0 $CRM_ATTR_FOREVER -N "$NODENAME" \
                -n "$PGSQL_DATA_STATUS_ATTR" -G -q`
        if [ "$output" = "DISCONNECT" ]; then
            change_pgsql_status "$NODENAME" "HS:alone"
        fi
    fi
    return $rc
}

#pgsql_monitor: pgsql_real_monitor() wrapper for replication
pgsql_monitor() {
    local rc

    # PostgreSQLにSELECTを投げて状態を確認する。
    # レプリケーション構成時、Slaveの場合はOCF_SUCCESSが、Masterの場合はOCF_RUNNING_MASTERが
    # 返ってくる
    pgsql_real_monitor
    rc=$?
    if ! is_replication; then
        return $rc
    else
        # レプリケーション使用時は、このmonitor処理の中で、続けてMaster/Slave用の制御を開始する
        # rcを引数で渡すことで、関数内でMaster用、Slave用の制御が選択される
        pgsql_replication_monitor $rc
        return $?
    fi
}

# demote完了後に呼び出される関数
# pgsql_post_demote
pgsql_post_demote() {
    # demoteされたノード名を取得
    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
    DEMOTE_NODE=`echo $OCF_RESKEY_CRM_meta_notify_demote_uname | sed "s/ /\n/g" | head -1 | tr '[A-Z]' '[a-z]'`
    ocf_log debug "post-demote called. Demote uname is $DEMOTE_NODE"

    # demoteノードが自ノードじゃない場合、pgsql-master-baseline を表示する。
    # 3ノード以上の場合に、pgsql_pre_promote() で使用される。
    if [ "$DEMOTE_NODE" != "$NODENAME" ]; then
        if ! echo $OCF_RESKEY_CRM_meta_notify_master_uname | tr '[A-Z]' '[a-z]' | grep $NODENAME; then
            show_master_baseline
            change_pgsql_status "$NODENAME" "HS:alone"
        fi
    fi
    return $OCF_SUCCESS
}

# promote実行前に呼びされる関数
pgsql_pre_promote() {
    local master_baseline
    local my_master_baseline
    local cmp_location
    local number_of_nodes

    # If my data is newer than new master's one, I fail my resource.

    # promoteされるノード名を取得
    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
    PROMOTE_NODE=`echo $OCF_RESKEY_CRM_meta_notify_promote_uname | \
                  sed "s/ /\n/g" | head -1 | tr '[A-Z]' '[a-z]'`
    number_of_nodes=`echo $NODE_LIST | wc -w`

    # レプリケーション構成に参加しているノード数が3ノード以上の場合で、かつrep_mode=syncの時のみ処理を実施
    # ※ rep_mode=sync の場合、Master故障時はSTREAMING|SYNCのノードがpromoteされるが、PostgreSQLの仕様上、STREAMING|SYNC
    #    以外のノードの方がデータが進んでいる可能性があり、この時新Masterとの間でデータの不整合が発生する可能性がある。
    #    そのため、新Masterよりも自分のデータが進んでいる場合はリソースを強制的に故障させPostgreSQLを停止させる。
    #    (戦略としてあまり綺麗じゃないので、もっとよいアイデアを募集)
    if [ $number_of_nodes -ge 3 -a \
         "$OCF_RESKEY_rep_mode" = "sync" -a \
         "$PROMOTE_NODE" != "$NODENAME" ]; then

        # promote予定のノードのデータの位置(pgsql-master-baseline)の値を取得。
        # ※ この値は、pgsql_post_demote 内での処理で全Slaveノードに表示されるため、それを取得している
        master_baseline=`$CRM_ATTR_REBOOT -N "$PROMOTE_NODE" -n \
                         "$PGSQL_MASTER_BASELINE" -G -q 2>/dev/null`
        if [ $? -eq 0 ]; then
            my_master_baseline=`$CRM_ATTR_REBOOT -N "$NODENAME" -n \
                                "$PGSQL_MASTER_BASELINE" -G -q 2>/dev/null`

            # データの新旧を比較
            # get older location
            cmp_location=`printf "$master_baseline\n$my_master_baseline\n" |\
                          sort | head -1`

            # 自分のデータが新Masterより新しければリソースを故障させる
            if [ "$cmp_location" != "$my_master_baseline" ]; then
                ocf_log err "My data is newer than new master's one. New master's location : $master_baseline"
                exec_with_retry 0 $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $NODENAME -v INFINITY
                return $OCF_ERR_GENERIC
            fi
        fi
    fi
    return $OCF_SUCCESS
}

pgsql_notify() {
    local type="${OCF_RESKEY_CRM_meta_notify_type}"
    local op="${OCF_RESKEY_CRM_meta_notify_operation}"
    local rc

    if ! is_replication; then
        return $OCF_SUCCESS
    fi

    ocf_log debug "notify: ${type} for ${op}"
    case $type in
        pre)
            case $op in
                promote)
                    pgsql_pre_promote
                    return $?
                    ;;
            esac
            ;;
        post)
            case $op in
                promote)
                    delete_xlog_location
                    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
                    PROMOTE_NODE=`echo $OCF_RESKEY_CRM_meta_notify_promote_uname | \
                                  sed "s/ /\n/g" | head -1 | tr '[A-Z]' '[a-z]'`
                    if [ "$PROMOTE_NODE" != "$NODENAME" ]; then
                        delete_master_baseline
                    fi
                    return $OCF_SUCCESS
                    ;;
                demote)
                    pgsql_post_demote
                    return $?
                    ;;
                start|stop)
                    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
                    MASTER_NODE=`echo $OCF_RESKEY_CRM_meta_notify_master_uname | \
                                  sed "s/ /\n/g" | head -1 | tr '[A-Z]' '[a-z]'`

                    # どこかのノードがstartしたりstopした場合、Masterへのレプリケーション接続状態が変わる
                    # 可能性が高いため、自分がMasterの場合はSlaveの状態を制御する関数をすぐに呼び出す
                    if [ "$NODENAME" = "$MASTER_NODE" ]; then
                        control_slave_status
                    fi
                    return $OCF_SUCCESS
                    ;;
            esac
            ;;
    esac
    return $OCF_SUCCESS
}

# 自分がMasterの時に、Slaveの状態を制御するための関数
control_slave_status() {
    local rc
    local data_status
    local target
    local all_data_status
    local tmp_data_status
    local number_of_nodes

    # Slaveの状態を確認するために、pg_stat_replication ビューの結果を取得
    # (取得結果例)
    # srv02|STREAMING|SYNC
    # srv03|STREAMING|ASYNC
    all_data_status=`su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; \
                     $OCF_RESKEY_psql $psql_options -U $OCF_RESKEY_pgdba \
                     -Atc \"${CHECK_REPLICATION_STATE_SQL}\""`
    rc=$?
    if [ $rc -eq 0 ]; then
        if [ -n "$all_data_status" ]; then
            # 取得したデータは改行で区切られているが、処理しやすくするために、
            # 改行をスペースに変換
            # (変換後の例)
            # srv02|STREAMING|SYNC srv03|STREAMING|ASYNC
            all_data_status=`echo $all_data_status | sed "s/\n/ /g"`
        fi
    else
        report_psql_error $rc err "Can't get PostgreSQL replication status."
        return 1
    fi

    # レプリケーションに参加しているノード数を取得
    number_of_nodes=`echo $NODE_LIST | wc -w`

    # レプリケーションに参加しているノード全てに対して処理を実行
    # NODE_LIST は RA のパラメータ node_list から取得。
    # Pacemaker制御外からレプリケーション接続があると、RAは
    # どのSlaveを制御すればよいか判断できないため、ユーザに
    # 明示的にクラスタに参加させるノードをパラメータに設定してもらっている
    # ※ crm_mon でクラスタに参加しているノード名を拾うことも考えたが、
    #    なるべくcrm_monの表示に依存したくなかったので、パラメータにした。
    for target in $NODE_LIST; do

        # 処理対象が自分の場合はスキップ
        if [ "$target" = "$NODENAME" ]; then
            continue
        fi

        # 処理対象(Slave)のpgsql-data-statusの初期値は DISCONNECT に設定
        data_status="DISCONNECT"

        if [ -n "$all_data_status" ]; then
            for tmp_data_status in $all_data_status; do
                # 処理対象のノードのデータかどうか判定
                if ! echo $tmp_data_status | grep -q "^${target}|"; then
                    # 処理対象じゃなければ次のデータを取得
                    continue
                fi
                data_status=`echo $tmp_data_status | cut -d "|" -f 2,3`
                ocf_log debug "node_name and data_status is $tmp_data_status"
                break
            done
        fi

        case "$data_status" in
            "STREAMING|SYNC")
                # 同期レプリケーション接続時の処理

                # change_xxx_status は、実際には値が異なる場合だけ設定を実行するように実装
                change_data_status "$target" "$data_status"
                change_master_score "$target" "$CAN_PROMOTE"
                change_pgsql_status "$target" "HS:sync"
                ;;
            "STREAMING|ASYNC")
                # 非同期レプリケーション時の処理
                change_data_status "$target" "$data_status"
                if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                    change_master_score "$target" "$CAN_NOT_PROMOTE"
                    # rep_mode=syncの場合、対象のノードを同期レプリケーションに変更する
                    set_sync_mode "$target"
                else
                    # rep_mode=asyncで2ノード数が2つの場合は、対象ノードはフェイルオーバ可能とする
                    # 3ノード以上の場合、フェイルオーバ先が複数あると、Master故障時にどちらのデータが
                    # 新しいかこの時点では判断できないため、SlaveはMasterに昇格できないように設定する
                    # -> Master故障時は、Master昇格権利があるかどうかの関数(have_master_right())に
                    #    入り、残ったSlave間でデータの比較を実施してもらう。(F/Oには時間がかかる)
                    if [ $number_of_nodes -le 2 ]; then
                        change_master_score "$target" "$CAN_PROMOTE"
                    else
                        # I can't determine which slave's data is newest in async mode.
                        change_master_score "$target" "$CAN_NOT_PROMOTE"
                    fi
                fi
                change_pgsql_status "$target" "HS:async"
                ;;
            "STREAMING|POTENTIAL")
                # rep_mode=sync で、かつ3ノード以上の場合は、1ノードがsyncで残りがpotentialになる
                # ただし、3ノード以上ではデータ欠損の可能性があり、このパッチを入れるとここには入らなくなる
                # https://github.com/t-matsuo/resource-agents/commit/bd3b587c6665c4f5eba0491b91f83965e601bb6b
                # ※ 1ノードしか同期レプリケーションの設定にしないパッチ
                change_data_status "$target" "$data_status"
                change_master_score "$target" "$CAN_NOT_PROMOTE"
                change_pgsql_status "$target" "HS:potential"
                ;;
            "DISCONNECT")
                # どれにも当てはまらない場合は、DISCONNECTとして処理
                change_data_status "$target" "$data_status"
                change_master_score "$target" "$CAN_NOT_PROMOTE"
                if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                    set_async_mode "$target"
                fi
                ;;
            *)
                change_data_status "$target" "$data_status"
                change_master_score "$target" "$CAN_NOT_PROMOTE"
                if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                    set_async_mode "$target"
                fi
                # タイミングによっては、CATCHUP|ASYNC といった状態遷移中ステータスもあり、このような場合、
                # HS:connected とする
                change_pgsql_status "$target" "HS:connected"
                ;;
        esac
    done
    return 0
}

# 自分がSlaveの場合、Masterになれる権利があるかどうかを確認するための関数
# なお、Masterがすでに存在する場合は呼び出されない
have_master_right() {
    local old
    local new
    local output
    local data_status
    local node
    local mylocation
    local count
    local newestXlog
    local oldfile
    local newfile

    ocf_log debug "Checking if I have a master right."

    data_status=`$CRM_ATTR_FOREVER -N "$NODENAME" -n \
                 "$PGSQL_DATA_STATUS_ATTR" -G -q 2>/dev/null`
    if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
        # rep_mode=syncで、自分のpgsql-data-statusがSTREAMING|SYNCでも
        # LATESTでもない場合は、Masterになる権利はなしと判断
        if [ -n "$data_status" -a "$data_status" != "STREAMING|SYNC" -a \
             "$data_status" != "LATEST" ]; then
            ocf_log warn "My data is out-of-date. status=$data_status"
            return 1
        fi
    else
        # rep_mode=asyncで、自分のpgsql-data-statusがSTREAMING|SYNCでも
        # STREAMING|ASYNCでもLATESTでもない場合は、Masterになる権利はなしと判断
        # ※ 通常 async 設定の場合、STREAMING|SYNCにはならないが、
        #    syncからasyncに設定を変更した場合はあり得るため、条件として入れている
        if [ -n "$data_status" -a "$data_status" != "STREAMING|SYNC" -a \
             "$data_status" != "STREAMING|ASYNC" -a \
             "$data_status" != "LATEST" ]; then
            ocf_log warn "My data is out-of-date. status=$data_status"
            return 1
        fi
    fi
    ocf_log info "My data status=$data_status."

    # 自分のデータの新旧を他のノードと比較するために、
    # 自分のデータの位置をpgsql-xlog-replay-loc属性値として公開
    show_xlog_location
    if [ $? -ne 0 ]; then
        ocf_log err "Failed to show my xlog location."
        exit $OCF_ERR_GENERIC
    fi

    old=0
    # xlog_check_count で指定された回数だけ、他のノードと
    # データの新旧を比較するという仕様。そのために、今回の比較回数が
    # 何回目かを確認。
    for count in `seq $OCF_RESKEY_xlog_check_count`; do
       # 下の方で、データの新旧比較結果を${XLOG_NOTE_FILE}.$countという
       # ファイルに書きこんでいるため、このファイルがどこまで存在するかを
       # 確認して今回の確認回数を判断する。
       if [ -f ${XLOG_NOTE_FILE}.$count ]; then
           old=$count
           continue
       fi
       break
    done
    new=`expr $old + 1`

    # 全ノードのpgsql-xlog-replay-loc(データの位置)を全て取得し、
    # ファイル(${XLOG_NOTE_FILE}.${new})に保存する。
    # もちろん、単ノード起動時は他のノードのデータの位置は取得できないため、
    # 結果的にファイルに書き込まれるのは自分のデータの位置だけとなる
    # get xlog locations of all nodes
    for node in ${NODE_LIST}; do
        output=`$CRM_ATTR_REBOOT -N "$node" -n \
                "$PGSQL_XLOG_LOC_NAME" -G -q 2>/dev/null`
        if [ $? -ne 0 ]; then
            ocf_log warn "Can't get $node xlog location."
            continue
        else
            ocf_log info "$node xlog location : $output"
            echo "$node $output" >> ${XLOG_NOTE_FILE}.${new}
            if [ "$node" = "$NODENAME" ]; then
                mylocation=$output
            fi
        fi
    done

    # 前回の比較結果を取得
    oldfile=`cat ${XLOG_NOTE_FILE}.${old} 2>/dev/null`
    # 今回の比較結果を取得
    newfile=`cat ${XLOG_NOTE_FILE}.${new} 2>/dev/null`

    # 前回と今回の比較結果に違いがある場合、どこかのノード上の
    # PostgreSQLがリカバリ中の可能性があるため、比較回数のカウンタを
    # 一旦リセットする。
    if [ "$oldfile" != "$newfile" ]; then
        # reset counter
        rm -f ${XLOG_NOTE_FILE}.*
        printf "$newfile\n" > ${XLOG_NOTE_FILE}.0
        return 1
    fi

    # 比較回数がxlog_check_countに達した場合、データの比較を実施し
    # 自分のデータが最も新しい場合は return 0 を返す
    if [ "$new" -ge "$OCF_RESKEY_xlog_check_count" ]; then
        # 比較には、ファイルの内容をsortすることで実現
        # ファイルソートの先頭行を見て判断すると、xlogの値が同じ物があった場合
        # 片方のみが最も新しいと判断されてしまうため、先頭行の値と自分のxlogの
        # 値を比較して自分が最も新しいデータをもっているかどうかを判断
        newestXlog=`printf "$newfile\n" | sort -t " " -k 2,3 -r | \
                    head -1 | cut -d " " -f 2`
        if [ "$newestXlog" = "$mylocation" ]; then
            ocf_log info "I have a master right."
            # 自分が最新のデータを持っている場合、masterスコアを
            # 上げて、promote されるのを待つ
            exec_with_retry 5 $CRM_MASTER -v $PROMOTE_ME
            return 0
        fi

        # 自分のデータが最新ではない場合、pgsql-data-status を
        # DISCONNECT にセットし、Masterになれないようにする。
        change_data_status "$NODENAME" "DISCONNECT"
        ocf_log info "I don't have correct master data."

        # promote されるを待っていても、実際にはpromoteが呼ばれないことがあり
        # その時はここに入ってきて、カウンタがリセットされる。
        # その結果、また比較がやり直される。
        # reset counter
        rm -f ${XLOG_NOTE_FILE}.*
        printf "$newfile\n" > ${XLOG_NOTE_FILE}.0
    fi

    return 1
}

is_replication() {
    if [ "$OCF_RESKEY_rep_mode" != "none" -a "$OCF_RESKEY_rep_mode" != "slave" ]; then
        return 0
    fi
    return 1
}

get_my_location() {
    local rc
    local output
    local replay_loc
    local receive_loc
    local output1
    local output2
    local log1
    local log2
    local newer_location


    # pg_last_xlog_replay_location() と pg_last_xlog_receive_location() を取得
    output=`su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; \
            $OCF_RESKEY_psql $psql_options -U $OCF_RESKEY_pgdba \
            -Atc \"${CHECK_XLOG_LOC_SQL}\""`
    rc=$?
    if [ $rc -ne 0 ]; then
        report_psql_error $rc err "Can't get my xlog location."
        return 1
    fi
    replay_loc=`echo $output | cut -d "|" -f 1`
    receive_loc=`echo $output | cut -d "|" -f 2`

    output1=`echo "$replay_loc" | cut -d "/" -f 1`
    output2=`echo "$replay_loc" | cut -d "/" -f 2`
    log1=`printf "%08s\n" $output1 | sed "s/ /0/g"`
    log2=`printf "%08s\n" $output2 | sed "s/ /0/g"`
    replay_loc="${log1}${log2}"

    output1=`echo "$receive_loc" | cut -d "/" -f 1`
    output2=`echo "$receive_loc" | cut -d "/" -f 2`
    log1=`printf "%08s\n" $output1 | sed "s/ /0/g"`
    log2=`printf "%08s\n" $output2 | sed "s/ /0/g"`
    receive_loc="${log1}${log2}"

    # pg_last_xlog_replay_location() と pg_last_xlog_receive_location() のうち、
    # 新しい方を自分のデータの位置として使用する。
    newer_location=`printf "$replay_loc\n$receive_loc" | sort -r | head -1`
    echo "$newer_location"
    return 0
}

show_xlog_location() {
    local location

    location=`get_my_location` || return 1
    exec_with_retry 0 $CRM_ATTR_REBOOT -N "$NODENAME" -n "$PGSQL_XLOG_LOC_NAME" -v "$location"
}

delete_xlog_location() {
    exec_with_retry 5 $CRM_ATTR_REBOOT -N "$NODENAME" -n "$PGSQL_XLOG_LOC_NAME" -D
}

show_master_baseline() {
    local rc
    local location

    location=`get_my_location`
    ocf_log info "My master baseline : $location."
    exec_with_retry 0 $CRM_ATTR_REBOOT -N "$NODENAME" -n "$PGSQL_MASTER_BASELINE" -v "$location"
}

delete_master_baseline() {
    exec_with_retry 5 $CRM_ATTR_REBOOT -N "$NODENAME" -n "$PGSQL_MASTER_BASELINE" -D
}

# 全てのノードの設定を非同期にする関数。synchronous_standby_names の設定を空にするだけ。
set_async_mode_all() {
    [ "$OCF_RESKEY_rep_mode" = "sync" ] || return 0
    ocf_log info "Set all nodes into async mode."
    runasowner -q err "echo \"synchronous_standby_names = ''\" > \"$REP_MODE_CONF\""
    if [ $? -ne 0 ]; then
        ocf_log err "Can't set all nodes into async mode."
        return 1
    fi
    return 0
}

# 指定されたノードを非同期設定にする関数
# postgresql.conf の synchronous_standby_names を書き換えて、reload している。
set_async_mode() {
    # REP_MODE_CONFに非同期設定対象のノード名があるかどうか判断
    cat $REP_MODE_CONF |  grep -q -e "[,' ]$1[,' ]"
    if [ $? -eq 0 ]; then
        ocf_log info "Setup $1 into async mode."
        echo "synchronous_standby_names = ''" > "$REP_MODE_CONF"
    else
        ocf_log debug "$1 is already in async mode."
        return 0
    fi
    exec_with_retry 0 reload_conf
}

# 指定されたノードを同期設定にする関数
# postgresql.conf の synchronous_standby_names を書き換えて、reload している。
set_sync_mode() {
    local sync_node_in_conf

    # 現在同期で動いているノード名を取得
    sync_node_in_conf=`cat $REP_MODE_CONF | cut -d "'" -f 2`
    if [ -n "$sync_node_in_conf" ]; then
        # すでに同期で動いているノードがいる場合は、他のノードは同期設定に
        # 変更しない
        # ※ 3ノード以上存在していて、2ノードが同期設定になると、
        #    データ欠損が発生する可能性があるため、同期設定にする
        #    のは1ノードのみに変更した
        # https://github.com/t-matsuo/resource-agents/commit/55494b5052f540030938733ec4729cc37ac64a8c#heartbeat/pgsql
        ocf_log debug "$sync_node_in_conf is already sync mode."
    else
        ocf_log info "Setup $1 into sync mode."
        echo "synchronous_standby_names = '$1'" > "$REP_MODE_CONF"
        [ "$RE_CONTROL_SLAVE" = "false" ] && RE_CONTROL_SLAVE="true"
        exec_with_retry 0 reload_conf
    fi
}

# pg_ctl reload で設定をリロードする。同期モード設定変更を反映するために使用される。
reload_conf() {
    # Invoke pg_ctl
    runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata reload"
    if [ $? -eq 0 ]; then
        ocf_log info "Reload configuration file."
    else
        ocf_log err "Can't reload configuration file."
        return 1
    fi

    return 0
}

# ユーザがrecovery.confに追加で設定したいパラメータがある場合は追加する
user_recovery_conf() {
    # put archive_cleanup_command and recovery_end_command only when defined by user
    if [ -n "$OCF_RESKEY_archive_cleanup_command" ]; then
        echo "archive_cleanup_command = '${OCF_RESKEY_archive_cleanup_command}'"
    fi
    if [ -n "$OCF_RESKEY_recovery_end_command" ]; then
        echo "recovery_end_command = '${OCF_RESKEY_recovery_end_command}'"
    fi
}

# start時にSlaveで起動するために、recovery.conf を作成する関数
# application_nameに自分のノード名を入れることで、Master側のpg_stat_replicationビューに
# Slaveの状態を表示させている
make_recovery_conf() {
    runasowner "touch $RECOVERY_CONF"
    if [ $? -ne 0 ]; then
        ocf_log err "Can't create recovery.conf."
        return 1
    fi

    # recovery.conf の基本設定作成
cat > $RECOVERY_CONF <<END
standby_mode = 'on'
primary_conninfo = 'host=${OCF_RESKEY_master_ip} port=${OCF_RESKEY_pgport} user=${OCF_RESKEY_repuser} application_name=${NODENAME} ${OCF_RESKEY_primary_conninfo_opt}'
restore_command = '${OCF_RESKEY_restore_command}'
recovery_target_timeline = 'latest'
END

    user_recovery_conf >> $RECOVERY_CONF
    ocf_log debug "Created recovery.conf. host=${OCF_RESKEY_master_ip}, user=${OCF_RESKEY_repuser}"
    return 0
}

# pgsql-status を変更する関数
# arg1:node, arg2: value
change_pgsql_status() {
    local output

    if ! is_node_online $1; then
        return 0
    fi

    # 指定されたノードの現在のpgsql-statusの値を取得
    output=`$CRM_ATTR_REBOOT -N "$1" -n "$PGSQL_STATUS_ATTR" -G -q 2>/dev/null`

    # crm_attributeコマンドでの書込が頻繁に呼びされるのを防ぐため、現在の値と設定したい値が
    # 異なる場合のみ、crm_attribute コマンドを使って値を変更する
    if [ "$output" != "$2" ]; then

        # Slaveのディスクが故障してPIDファイルが読めない場合、SlaveのRAはPostgreSQL停止とみなし、
        # pgsql-status=STOP に変更する。
        # しかし、実際はPostgreSQLのプロセスは一定期間生き続けるため、 レプリケーション接続が残り
        # Master は Slave が生きていると認識し、結果、pgsql-status を STOP から HS:sync などに
        # 上書きしてしまう。これを避けるため、Slave の pgsql-status が STOP や UNKNOWN の場合
        # Maste は Slave の pgsql-status を上書きしないようにする。
        if [ "$output" = "STOP" -o "$output" = "UNKNOWN" ]; then
            if [ "$1" != "$NODENAME" ]; then
                ocf_log warn "Changing $PGSQL_STATUS_ATTR on $1 : $output->$2 by $NODENAME is prohibited."
                return 0
            fi
        fi

        ocf_log info "Changing $PGSQL_STATUS_ATTR on $1 : $output->$2."
        exec_with_retry 0 $CRM_ATTR_REBOOT -N "$1" -n "$PGSQL_STATUS_ATTR" -v "$2"
    fi
    return 0
}

# pgsql-data-status を変更する関数。
# arg1:node, arg2: value
change_data_status() {
    local output

    if ! node_exist $1; then
        return 0
    fi

    while :
    do
        # pgsql-data-status は Pacemaker 停止後も属性値を残すため、crm_attribute の
        # forever オプションで設定する。
        output=`$CRM_ATTR_FOREVER -N "$1" -n "$PGSQL_DATA_STATUS_ATTR" -G -q 2>/dev/null`
        if [ "$output" != "$2" ]; then
            ocf_log info "Changing $PGSQL_DATA_STATUS_ATTR on $1 : $output->$2."

            # 電源断などによりDCノードが移動している最中に、forever属性の値を変更しようとすると
            # crm_attribute コマンドは無応答となってしまうため、タイムアウトを設定して実行する。
            # timeout のデフォルト値は5秒。
            # さらに、crm_attributeコマンド実行失敗時はリトライをかける。
            exec_with_retry 0 exec_with_timeout 0 "$CRM_ATTR_FOREVER" -N $1 -n $PGSQL_DATA_STATUS_ATTR -v "$2"
        else
            break
        fi
    done
    return 0
}

# 他ノードのマスタスコアを設定する関数
# arg1:node, arg2: score, arg3: resoure
set_master_score() {
    local current_score

    current_score=`$CRM_ATTR_REBOOT -N "$1" -n "master-$3" -G -q 2>/dev/null`
    if [ -n "$current_score" -a "$current_score" != "$2" ]; then
        ocf_log info "Changing $3 master score on $1 : $current_score->$2."
        exec_with_retry 0 $CRM_ATTR_REBOOT -N "$target" -n "master-$3" -v "$2"
    fi
    return 0
}

# 他ノードのマスタスコアを設定する関数。set_master_score()のラッパー関数
# ※ 自ノードのマスタスコアは変更できないので、crm_masterコマンドを直接実行すること。
# arg1:node, arg2: score
change_master_score() {
    local instance

    # 指定されたノードがonlineでなければ変更できないので何もしない
    if ! is_node_online $1; then
        return 0
    fi

    # Pacemakerのバージョンによって OCF_RESOURCE_INSTANCE にインスタンス番号が
    # ある場合とない場合があるので処理を分岐
    if echo $OCF_RESOURCE_INSTANCE | grep -q ":"; then
        # If Pacemaker version is 1.0.x
        instance=0

        # インスタンス番号の入れ替えが発生する可能性があるので、指定されたノード上の
        # 全てのインスタンスについてマスタスコアを変更する。
        while :
        do
            if [ "$instance" -ge "$OCF_RESKEY_CRM_meta_clone_max" ]; then
                break
            fi
            # インスタンス番号が自分ノードインスタンス番号ならば変更する必要がないためスキップ
            if [ "${RESOURCE_NAME}:${instance}" = "$OCF_RESOURCE_INSTANCE" ]; then
                instance=`expr $instance + 1`
                continue
            fi
            # マスタスコア変更
            set_master_score $1 $2 "${RESOURCE_NAME}:${instance}" || return 1
            instance=`expr $instance + 1`
        done
    else
        # If globally-unique=false and Pacemaker version is 1.1.8 or higher 
        # Master/Slave resource has no instance number
        set_master_score $1 $2 ${RESOURCE_NAME} || return 1
    fi
    return 0
}

# psqlコマンド実行時のエラー内容をログに出力するための関数。
report_psql_error()
{
    local rc
    local loglevel
    local message

    rc=$1
    loglevel=${2:-err}
    message="$3"

    ocf_log $loglevel "$message rc=$rc"
    if [ $rc -eq 1 ]; then
        ocf_log err "Fatal error (out of memory, file not found, etc.) occurred while executing the psql command."
    elif [ $rc -eq 2 ]; then
        ocf_log $loglevel "Connection error (connection to the server went bad and the session was not interactive) occurred while executing the psql command."
    elif [ $rc -eq 3 ]; then
        ocf_log err "Script error (the variable ON_ERROR_STOP was set) occurred while executing the psql command."
    fi
}

#
# タイムアウトを設定して、指定されたコマンドを実行する。
# DCノード遷移中にcrm_attribute -l forever を使うとコマンドが無応答になるための対策用関数。
# timeout management function
# arg1   timeout >= 0 (if arg1 is 0, OCF_RESKEY_crm_attr_timeout is used.)
# arg2 : command
# arg3 : command's args
exec_with_timeout() {
    local func_pid
    local count=$OCF_RESKEY_crm_attr_timeout
    local rc

    if [ "$1" -ne 0 ]; then
        count=$1
    fi
    shift

    $* &
    func_pid=$!
    sleep .1

    while kill -s 0 $func_pid >/dev/null 2>&1; do
        sleep 1
        count=`expr $count - 1`
        if [ $count -le 0 ]; then
            ocf_log err "\"$*\" (pid=$func_pid) timed out."
            # 指定された時間内にコマンドが応答を返さない場合は、プロセスをkillする。
            kill -s 9 $func_pid >/dev/null 2>&1
            return 1
        fi
        ocf_log info "Waiting($count). \"$*\" (pid=$func_pid)."
    done
    wait $func_pid
}

# crm_xxx コマンドの接続数には限界があるため、crm_xxx コマンド失敗した場合に
# リトライするための関数
# retry command when command doesn't return 0
# arg1       : count >= 0 (if arg1 is 0, it retries command in infinitum(1day))
# arg2..argN : command and args
exec_with_retry() {
    local count="86400"
    local output
    local rc

    if [ "$1" -ne 0 ]; then
        count=$1
    fi
    shift

    while [ $count -gt 0 ]; do
        output=`$*`
        rc=$?
        if [ $rc -ne 0 ]; then
            ocf_log warn "Retrying(remain $count). \"$*\" failed. rc=$rc. stdout=\"$output\"."
            count=`expr $count - 1`
            sleep 1
        else
            printf "${output}"
            return 0
        fi
    done

    ocf_log err "giving up executing \"$*\""
    return $rc
}

# 指定したノードがonlineかどうかを判断するための関数
is_node_online() {
    # PM1.0とPM1.1でcrm_monの出力が微妙に異なるため、"^node $1 " と "^node $1:" で grepしている
    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
    print_crm_mon | tr '[A-Z]' '[a-z]' | grep -e "^node $1 " -e "^node $1:" | grep -q -v "offline"
}

# 指定したノードが存在するかどうかを判断するための関数 (onlineかどうかは問わない)
node_exist() {
    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換してからgrepする
    print_crm_mon | tr '[A-Z]' '[a-z]' | grep -q "^node $1"
}

check_binary2() {
    if ! have_binary "$1"; then
        ocf_log err "Setup problem: couldn't find command: $1"
        return 1
    fi
    return 0
}

# postgresql.conf が読み取れるか確認する関数
check_config() {
    local rc=0

    if [ ! -f "$1" ]; then
        if ocf_is_probe; then
           ocf_log info "Configuration file is $1 not readable during probe."
           rc=1
        else
           ocf_log err "Configuration file $1 doesn't exist"
           rc=2
        fi
    fi

    return $rc
}

# Validate most critical parameters
pgsql_validate_all() {
    local version
    local check_config_rc
    local rep_mode_string

    if ! check_binary2 "$OCF_RESKEY_pgctl" || 
       ! check_binary2 "$OCF_RESKEY_psql"; then
        return $OCF_ERR_INSTALLED
    fi

    check_config "$OCF_RESKEY_config"
    check_config_rc=$?
    [ $check_config_rc -eq 2 ] && return $OCF_ERR_INSTALLED
    [ $check_config_rc -eq 0 ] && : ${OCF_RESKEY_socketdir=`get_pgsql_param unix_socket_directory`}

    getent passwd $OCF_RESKEY_pgdba >/dev/null 2>&1
    if [ ! $? -eq 0 ]; then
        ocf_log err "User $OCF_RESKEY_pgdba doesn't exist";
        return $OCF_ERR_INSTALLED;
    fi

    if ocf_is_probe; then
        ocf_log info "Don't check $OCF_RESKEY_pgdata during probe"
    else
        if ! runasowner "test -w $OCF_RESKEY_pgdata"; then
            ocf_log err "Directory $OCF_RESKEY_pgdata is not writable by $OCF_RESKEY_pgdba"
            return $OCF_ERR_PERM;
        fi
    fi

    if [ -n "$OCF_RESKEY_monitor_user" -a ! -n "$OCF_RESKEY_monitor_password" ]
    then
        ocf_log err "monitor password can't be empty"
        return $OCF_ERR_CONFIGURED
    fi

    if [ ! -n "$OCF_RESKEY_monitor_user" -a -n "$OCF_RESKEY_monitor_password" ]
    then
        ocf_log err "monitor_user has to be set if monitor_password is set"
        return $OCF_ERR_CONFIGURED
    fi

    if is_replication || [ "$OCF_RESKEY_rep_mode" = "slave" ]; then
        # レプリケーション使用時は、PG9.1以上が必要なため、使用しているPGのバージョンをチェック
        version=`cat $OCF_RESKEY_pgdata/PG_VERSION`
        if [ `printf "$version\n9.1" | sort -n | head -1` != "9.1" ]; then
            ocf_log err "Replication mode needs PostgreSQL 9.1 or higher."
            return $OCF_ERR_INSTALLED
        fi
        if [ ! -n "$OCF_RESKEY_master_ip" ]; then
            ocf_log err "master_ip can't be empty."
            return $OCF_ERR_CONFIGURED
        fi
    fi

    # rep_mode に何か設定されている場合 (rep_mode=slaveを除く)
    if is_replication; then

        # Pacemakerの設定がMaster/Slaveになっていない場合はエラー
        if ! ocf_is_ms; then
            ocf_log err "Replication(rep_mode=async or sync) requires Master/Slave configuration."
            return $OCF_ERR_CONFIGURED
        fi

        # rep_mode=sync, async 以外が設定されている場合はエラー
        if [ ! "$OCF_RESKEY_rep_mode" = "sync" -a ! "$OCF_RESKEY_rep_mode" = "async" ]; then
            ocf_log err "Invalid rep_mode : $OCF_RESKEY_rep_mode"
            return $OCF_ERR_CONFIGURED
        fi

        # node_list パラメータが設定されていない場合はエラー
        if [ ! -n "$NODE_LIST" ]; then
            ocf_log err "node_list can't be empty."
            return $OCF_ERR_CONFIGURED
        fi

        # postgresql.conf ファイルが正常に読み書きできるならば
        if [ $check_config_rc -eq 0 ]; then
            rep_mode_string="include '$REP_MODE_CONF' # added by pgsql RA"
            if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                if ! grep -q "$rep_mode_string" $OCF_RESKEY_config; then
                    # postgresql.confに、include文が追加されていいない場合は追加。
                    # RAは、インクルード先の #OCF_RESKEY_configに
                    # synchronous_standby_names パラメータだけを記述し、RAは、同期・非同期切り替えに
                    # このファイルを変更する (set_sync_mode や set_async_mode 関数内)
                    ocf_log info "adding include directive into $OCF_RESKEY_config"
                    echo "$rep_mode_string" >> $OCF_RESKEY_config
                fi
            else
                # rep_mode=sync 以外の場合、RAで追加したinclude文があれば削除する (コミュニティ要望)
                if grep -q "$rep_mode_string" $OCF_RESKEY_config; then
                    ocf_log info "deleting include directive from $OCF_RESKEY_config"
                    sed -i "/${rep_mode_string//\//\\/}/d" $OCF_RESKEY_config
                fi
            fi
        fi
        # RAが使用するテンポラリディレクトリを作成
        if ! mkdir -p $OCF_RESKEY_tmpdir || ! chown $OCF_RESKEY_pgdba $OCF_RESKEY_tmpdir || ! chmod 700 $OCF_RESKEY_tmpdir; then
            ocf_log err "Can't create directory $OCF_RESKEY_tmpdir or it is not readable by $OCF_RESKEY_pgdba"
            return $OCF_ERR_PERM
        fi
    fi

    # rep_mode=slave は、Master/Slave 構成ではなく、Act-SbyのPostgreSQLをSlave(HS)で起動するためだけの動作をするため、
    # 間違ってMaster/Slave 設定されている場合はエラーとする。
    if [ "$OCF_RESKEY_rep_mode" = "slave" ]; then
        if ocf_is_ms; then
            ocf_log err "Replication(rep_mode=slave) does not support Master/Slave configuration."
            return $OCF_ERR_CONFIGURED
        fi
    fi

    return $OCF_SUCCESS
}


#
# Check if we need to create a log file
#

check_log_file() {
    if [ ! -f "$1" ]
    then
        touch $1 > /dev/null 2>&1
        chown $OCF_RESKEY_pgdba:`getent passwd $OCF_RESKEY_pgdba | cut -d ":" -f 4` $1
    fi

    #Check if $OCF_RESKEY_pgdba can write to the log file
    if ! runasowner "test -w $1"
    then
        return 1
    fi

    return 0
}

#
# Check socket directory
#
check_socket_dir() {
    if [ ! -d "$OCF_RESKEY_socketdir" ]; then
        if ! mkdir "$OCF_RESKEY_socketdir"; then
            ocf_log err "Can't create directory $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi

        if ! chown $OCF_RESKEY_pgdba:`getent passwd \
             $OCF_RESKEY_pgdba | cut -d ":" -f 4` "$OCF_RESKEY_socketdir" 
        then
            ocf_log err "Can't change ownership for $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi

        if ! chmod 2775 "$OCF_RESKEY_socketdir"; then
            ocf_log err "Can't change permissions for $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi
    else
        if ! runasowner "touch $OCF_RESKEY_socketdir/test.$$"; then
            ocf_log err "$OCF_RESKEY_pgdba can't create files in $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi
        rm $OCF_RESKEY_socketdir/test.$$
    fi
}

print_crm_mon() {
    if [ -z "$CRM_MON_OUTPUT" ]; then
        CRM_MON_OUTPUT=`exec_with_retry 0 crm_mon -n1`
    fi
    printf "${CRM_MON_OUTPUT}\n"
}

#
#   'main' starts here...
#


if [ $# -ne 1 ]
then
    usage
    exit $OCF_ERR_GENERIC
fi


PIDFILE=${OCF_RESKEY_pgdata}/postmaster.pid
BACKUPLABEL=${OCF_RESKEY_pgdata}/backup_label
RESOURCE_NAME=`echo $OCF_RESOURCE_INSTANCE | cut -d ":" -f 1`
PGSQL_WAL_RECEIVER_STATUS_ATTR="${RESOURCE_NAME}-receiver-status"
RECOVERY_CONF=${OCF_RESKEY_pgdata}/recovery.conf

# Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
NODENAME=`uname -n | tr '[A-Z]' '[a-z]'`

# レプリケーション構成時のみ必要な変数をセット
if is_replication; then
    REP_MODE_CONF=${OCF_RESKEY_tmpdir}/rep_mode.conf
    PGSQL_LOCK=${OCF_RESKEY_tmpdir}/PGSQL.lock
    XLOG_NOTE_FILE=${OCF_RESKEY_tmpdir}/xlog_note

    CRM_MASTER="${HA_SBIN_DIR}/crm_master -l reboot"
    CRM_ATTR_REBOOT="${HA_SBIN_DIR}/crm_attribute -l reboot"
    CRM_ATTR_FOREVER="${HA_SBIN_DIR}/crm_attribute -l forever"
    CRM_FAILCOUNT="${HA_SBIN_DIR}/crm_failcount"

    CAN_NOT_PROMOTE="-INFINITY"
    CAN_PROMOTE="100"
    PROMOTE_ME="1000"

    # Master/Slave どちらで動いているかを判断するためのSQL
    CHECK_MS_SQL="select pg_is_in_recovery()"
    # PostgreSQLのデータの位置を取得するためのSQL
    CHECK_XLOG_LOC_SQL="select pg_last_xlog_replay_location(),pg_last_xlog_receive_location()"
    # Master時に、Slaveの接続状態を取得するためのSQL
    CHECK_REPLICATION_STATE_SQL="select application_name,upper(state),upper(sync_state) from pg_stat_replication"

    # 各種属性名。複数インスタンスでも動くように、属性名にはリソースIDを入れる
    # 本ファイルのコメント内では、RESOURCE_NAME=pgsql と仮定して書いているため、
    # pgsql-status, pgsql-data-status, pgsql-xlog-loc, pgsql-master-baseline となっている
    PGSQL_STATUS_ATTR="${RESOURCE_NAME}-status"
    PGSQL_DATA_STATUS_ATTR="${RESOURCE_NAME}-data-status"
    PGSQL_XLOG_LOC_NAME="${RESOURCE_NAME}-xlog-loc"
    PGSQL_MASTER_BASELINE="${RESOURCE_NAME}-master-baseline"

    # Heartbeatは大文字ホスト名も小文字として処理するため、ノード名は全て小文字に変換する
    NODE_LIST=`echo $OCF_RESKEY_node_list | tr '[A-Z]' '[a-z]'`
    RE_CONTROL_SLAVE="false"
fi

case "$1" in
    methods)    pgsql_methods
                exit $?;;

    meta-data)  meta_data
                exit $OCF_SUCCESS;;
esac

pgsql_validate_all
rc=$?

[ "$1" = "validate-all" ] && exit $rc

if [ $rc -ne 0 ]
then
    case "$1" in
        stop)    if is_replication; then
                    change_pgsql_status "$NODENAME" "UNKNOWN"
                 fi
                 exit $OCF_SUCCESS;;
        monitor) exit $OCF_NOT_RUNNING;;
        status)  exit $OCF_NOT_RUNNING;;
        *)       exit $rc;;
    esac
fi

US=`id -u -n`

if [ $US != root -a $US != $OCF_RESKEY_pgdba ]
then
    ocf_log err "$0 must be run as root or $OCF_RESKEY_pgdba"
    exit $OCF_ERR_GENERIC
fi

# make psql command options
if [ -n "$OCF_RESKEY_monitor_user" ]; then
    PGUSER=$OCF_RESKEY_monitor_user; export PGUSER
    PGPASSWORD=$OCF_RESKEY_monitor_password; export PGPASSWORD
    psql_options="-p $OCF_RESKEY_pgport $OCF_RESKEY_pgdb"
else
    psql_options="-p $OCF_RESKEY_pgport -U $OCF_RESKEY_pgdba $OCF_RESKEY_pgdb"
fi

if [ -n "$OCF_RESKEY_pghost" ]; then
   psql_options="$psql_options -h $OCF_RESKEY_pghost"
else
   if [ -n "$OCF_RESKEY_socketdir" ]; then
       psql_options="$psql_options -h $OCF_RESKEY_socketdir"
   fi
fi

# What kind of method was invoked?
case "$1" in
    status)     if pgsql_status
                then
                    ocf_log info "PostgreSQL is up"
                    exit $OCF_SUCCESS
                else
                    ocf_log info "PostgreSQL is down"
                    exit $OCF_NOT_RUNNING
                fi;;

    monitor)    pgsql_monitor
                exit $?;;

    start)      pgsql_start
                exit $?;;

    promote)    pgsql_promote
                exit $?;;

    demote)     pgsql_demote
                exit $?;;

    notify)     pgsql_notify
                exit $?;;

    stop)       pgsql_stop
                exit $?;;
    *)
                exit $OCF_ERR_UNIMPLEMENTED;;
esac
