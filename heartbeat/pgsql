#!/bin/sh
#
# Description:  Manages a PostgreSQL Server as an OCF High-Availability
#               resource
#
# Authors:      Serge Dubrouski (sergeyfd@gmail.com) -- original RA
#               Florian Haas (florian@linbit.com) -- makeover
#               Takatoshi MATSUO (matsuo.tak@gmail.com) -- support replication
#
# Copyright:    2006-2010 Serge Dubrouski <sergeyfd@gmail.com>
#                         and other Linux-HA contributors
# License:      GNU General Public License (GPL)
#
###############################################################################
# Initialization:

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

#
# Get PostgreSQL Configuration parameter
#
get_pgsql_param() {
    local config_file
    local param_name
    local loglevel=err

    if ocf_is_probe; then
        loglevel=warn
    fi

    param_name=$1
 
    #Check that config file exists 
    if [ -n "$OCF_RESKEY_config" ]; then
        config=$OCF_RESKEY_config
    else
        config=$OCF_RESKEY_pgdata/postgresql.conf
    fi

    if [ ! -f "$config" ]; then
        ocf_log $loglevel "Cannot find configuration file $config"
        return
    fi

    perl_code="if (/^\s*$param_name[\s=]+\s*(.*)$/) {
       \$dir=\$1;
       \$dir =~ s/\s*\#.*//;
       \$dir =~ s/^'(\S*)'/\$1/;
       print \$dir;}"

    perl -ne "$perl_code" < $config
}

# Defaults
OCF_RESKEY_pgctl_default=/usr/bin/pg_ctl
OCF_RESKEY_psql_default=/usr/bin/psql
OCF_RESKEY_pgdata_default=/var/lib/pgsql/data
OCF_RESKEY_pgdba_default=postgres
OCF_RESKEY_pghost_default=""
OCF_RESKEY_pgport_default=5432
OCF_RESKEY_config_default=""
OCF_RESKEY_start_opt_default=""
OCF_RESKEY_pgdb_default=template1
OCF_RESKEY_logfile_default=/dev/null
OCF_RESKEY_stop_escalate_default=30
OCF_RESKEY_monitor_user_default=""
OCF_RESKEY_monitor_password_default=""
OCF_RESKEY_monitor_sql_default="select now();"
# Defaults for replication
OCF_RESKEY_tmpdir_default="/var/lib/pgsql"
OCF_RESKEY_rep_mode_default=none
OCF_RESKEY_rep_mode_conf_default="${OCF_RESKEY_tmpdir_default}/PGSQL.${OCF_RESKEY_pgport_default}.rep_mode.conf"
OCF_RESKEY_show_status_default=no
OCF_RESKEY_pgctldata_default=/usr/bin/pg_controldata
OCF_RESKEY_startup_method_default=auto
OCF_RESKEY_recovery_conf_default="${OCF_RESKEY_tmpdir_default}/recovery.conf"
OCF_RESKEY_ip_list_default=""
OCF_RESKEY_node_list_default=""
OCF_RESKEY_xlog_note_default="${OCF_RESKEY_tmpdir_default}/PGSQL.${OCF_RESKEY_pgport_default}.xlog_note"
OCF_RESKEY_xlog_check_count_default="3"

: ${OCF_RESKEY_pgctl=${OCF_RESKEY_pgctl_default}}
: ${OCF_RESKEY_psql=${OCF_RESKEY_psql_default}}
: ${OCF_RESKEY_pgdata=${OCF_RESKEY_pgdata_default}}
: ${OCF_RESKEY_pgdba=${OCF_RESKEY_pgdba_default}}
: ${OCF_RESKEY_pghost=${OCF_RESKEY_pghost_default}}
: ${OCF_RESKEY_pgport=${OCF_RESKEY_pgport_default}}
: ${OCF_RESKEY_config=${OCF_RESKEY_config_default}}
: ${OCF_RESKEY_start_opt=${OCF_RESKEY_start_opt_default}}
: ${OCF_RESKEY_pgdb=${OCF_RESKEY_pgdb_default}}
: ${OCF_RESKEY_logfile=${OCF_RESKEY_logfile_default}}
: ${OCF_RESKEY_stop_escalate=${OCF_RESKEY_stop_escalate_default}}
: ${OCF_RESKEY_monitor_user=${OCF_RESKEY_monitor_user_default}}
: ${OCF_RESKEY_monitor_password=${OCF_RESKEY_monitor_password_default}}
: ${OCF_RESKEY_monitor_sql=${OCF_RESKEY_monitor_sql_default}}
# for replication
: ${OCF_RESKEY_tmpdir=${OCF_RESKEY_tmpdir_default}}
: ${OCF_RESKEY_rep_mode=${OCF_RESKEY_rep_mode_default}}
: ${OCF_RESKEY_rep_mode_conf=${OCF_RESKEY_rep_mode_conf_default}}
: ${OCF_RESKEY_show_status=${OCF_RESKEY_show_status_default}}
: ${OCF_RESKEY_pgctldata=${OCF_RESKEY_pgctldata_default}}
: ${OCF_RESKEY_startup_method=${OCF_RESKEY_startup_method_default}}
: ${OCF_RESKEY_recovery_conf=${OCF_RESKEY_recovery_conf_default}}
: ${OCF_RESKEY_ip_list=${OCF_RESKEY_ip_list_default}}
: ${OCF_RESKEY_node_list=${OCF_RESKEY_node_list_default}}
: ${OCF_RESKEY_xlog_note=${OCF_RESKEY_xlog_note_default}}
: ${OCF_RESKEY_xlog_check_count=${OCF_RESKEY_xlog_check_count_default}}

usage() {
    cat <<EOF
	usage: $0 start|stop|status|monitor|promote|demote|notify|meta-data|validate-all|methods

	$0 manages a PostgreSQL Server as an HA resource.

        The 'start' operation starts the PostgreSQL server.
        The 'stop' operation stops the PostgreSQL server.
        The 'status' operation reports whether the PostgreSQL is up.
        The 'monitor' operation reports whether the PostgreSQL is running.
        The 'promote' operations promotes the PostgreSQL server.
        The 'demote' operations demotes the PostgreSQL server.
        The 'validate-all' operation reports whether the parameters are valid.
        The 'methods' operation reports on the methods $0 supports.
EOF
  return $OCF_ERR_ARGS
}

meta_data() {
	cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgsql">
<version>1.0</version>

<longdesc lang="en">
Resource script for PostgreSQL. It manages a PostgreSQL as an HA resource.
</longdesc>
<shortdesc lang="en">Manages a PostgreSQL database instance</shortdesc>

<parameters>
<parameter name="pgctl" unique="0" required="0">
<longdesc lang="en">
Path to pg_ctl command.
</longdesc>
<shortdesc lang="en">pgctl</shortdesc>
<content type="string" default="${OCF_RESKEY_pgctl_default}" />
</parameter>

<parameter name="start_opt" unique="0" required="0">
<longdesc lang="en">
Start options (-o start_opt in pg_ctl). "-i -p 5432" for example.
</longdesc>
<shortdesc lang="en">start_opt</shortdesc>
<content type="string" default="${OCF_RESKEY_start_opt_default}" />

</parameter>
<parameter name="ctl_opt" unique="0" required="0">
<longdesc lang="en">
Additional pg_ctl options (-w, -W etc..).
</longdesc>
<shortdesc lang="en">ctl_opt</shortdesc>
<content type="string" default="${OCF_RESKEY_ctl_opt_default}" />
</parameter>

<parameter name="psql" unique="0" required="0">
<longdesc lang="en">
Path to psql command.
</longdesc>
<shortdesc lang="en">psql</shortdesc>
<content type="string" default="${OCF_RESKEY_psql_default}" />
</parameter>

<parameter name="pgdata" unique="0" required="0">
<longdesc lang="en">
Path to PostgreSQL data directory.
</longdesc>
<shortdesc lang="en">pgdata</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdata_default}" />
</parameter>

<parameter name="pgdba" unique="0" required="0">
<longdesc lang="en">
User that owns PostgreSQL.
</longdesc>
<shortdesc lang="en">pgdba</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdba_default}" />
</parameter>

<parameter name="pghost" unique="0" required="0">
<longdesc lang="en">
Hostname/IP address where PostgreSQL is listening
</longdesc>
<shortdesc lang="en">pghost</shortdesc>
<content type="string" default="${OCF_RESKEY_pghost_default}" />
</parameter>

<parameter name="pgport" unique="0" required="0">
<longdesc lang="en">
Port where PostgreSQL is listening
</longdesc>
<shortdesc lang="en">pgport</shortdesc>
<content type="integer" default="${OCF_RESKEY_pgport_default}" />
</parameter>

<parameter name="monitor_user" unique="0" required="0">
<longdesc lang="en">
PostgreSQL user that pgsql RA will user for monitor operations. If it's not set
pgdba user will be used.
</longdesc>
<shortdesc lang="en">monitor_user</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_user_default}" />
</parameter>

<parameter name="monitor_password" unique="0" required="0">
<longdesc lang="en">
Password for monitor user.
</longdesc>
<shortdesc lang="en">monitor_password</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_password_default}" />
</parameter>

<parameter name="monitor_sql" unique="0" required="0">
<longdesc lang="en">
SQL script that will be used for monitor operations.
</longdesc>
<shortdesc lang="en">monitor_sql</shortdesc>
<content type="string" default="${OCF_RESKEY_monitor_sql_default}" />
</parameter>

<parameter name="config" unique="0" required="0">
<longdesc lang="en">
Path to the PostgreSQL configuration file for the instance
</longdesc>
<shortdesc lang="en">Configuration file</shortdesc>
<content type="integer" default="${OCF_RESKEY_config_default}" />
</parameter>

<parameter name="pgdb" unique="0" required="0">
<longdesc lang="en">
Database that will be used for monitoring.
</longdesc>
<shortdesc lang="en">pgdb</shortdesc>
<content type="string" default="${OCF_RESKEY_pgdb_default}" />
</parameter>

<parameter name="logfile" unique="0" required="0">
<longdesc lang="en">
Path to PostgreSQL server log output file.
</longdesc>
<shortdesc lang="en">logfile</shortdesc>
<content type="string" default="${OCF_RESKEY_logfile_default}" />
</parameter>

<parameter name="socketdir" unique="0" required="0">
<longdesc lang="en">
Unix socket directory for PostgeSQL
</longdesc>
<shortdesc lang="en">socketdir</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="stop_escalate" unique="0" required="0">
<longdesc lang="en">
Number of shutdown retries (using -m fast) before resorting to -m immediate
</longdesc>
<shortdesc lang="en">stop escalation</shortdesc>
<content type="integer" default="${OCF_RESKEY_stop_escalation}" />
</parameter>

<parameter name="rep_mode" unique="0" required="0">
<longdesc lang="en">
Replication mode(none/async/sync).
"aync","sync" require PostgreSQL 9.1 or later.
</longdesc>
<shortdesc lang="en">rep_mode</shortdesc>
<content type="string" default="${OCF_RESKEY_rep_mode_default}" />
</parameter>

<parameter name="rep_mode_conf" unique="0" required="0">
<longdesc lang="en">
Path to rep_mode.conf file.
This file is used for "rep_mode=sync" to change replication mode by RA.
postgresql.conf needs include this file and don't write
synchronous_standby_names directive.
</longdesc>
<shortdesc lang="en">rep_mode_conf</shortdesc>
<content type="string" default="${OCF_RESKEY_rep_mode_conf_default}" />
</parameter>

<parameter name="tmpdir" unique="0" required="0">
<longdesc lang="en">
Path to temporary directory.
Used for streaming replication only.
</longdesc>
<shortdesc lang="en">tmpdir</shortdesc>
<content type="string" default="${OCF_RESKEY_tmpdir_default}" />
</parameter>

<parameter name="show_status" unique="0" required="0">
<longdesc lang="en">
show replication status(yes/no)
</longdesc>
<shortdesc lang="en">show status</shortdesc>
<content type="string" default="${OCF_RESKEY_show_status_default}" />
</parameter>

<parameter name="pgctldata" unique="0" required="0">
<longdesc lang="en">
Path to pg_controldata command.
</longdesc>
<shortdesc lang="en">pgctldata</shortdesc>
<content type="string" default="${OCF_RESKEY_pgctldata_default}" />
</parameter>

<parameter name="startup_method" unique="0" required="0">
<longdesc lang="en">
Method to select master or slave.(auto/recovery)
If you select "recovery", you have to put recovery.conf manually
and start only master's pacemaker at the beginning.
If you select "auto", I check pg_last_xlog_replay_location() and
get timeline ID files from master.
You have to set ip_list parameter to use "auto".
Used for streaming replication only.
</longdesc>
<shortdesc lang="en">startup method</shortdesc>
<content type="string" default="${OCF_RESKEY_startup_method_default}" />
</parameter>

<parameter name="recovery_conf" unique="0" required="0">
<longdesc lang="en">
Path to recovery.conf bakcup file.
Used for startup_method="auto".
</longdesc>
<shortdesc lang="en">recovery.conf</shortdesc>
<content type="string" default="${OCF_RESKEY_recovery_conf_method_default}" />
</parameter>

<parameter name="ip_list" unique="0" required="0">
<longdesc lang="en">
IP list used for checking xlog and get timeline ID files.
You have to configure PostgreSQL for permit connection to this IP.
Used for startup_method="auto".
</longdesc>
<shortdesc lang="en">ip list</shortdesc>
<content type="string" default="${OCF_RESKEY_ip_list_default}" />
</parameter>

<parameter name="node_list" unique="0" required="0">
<longdesc lang="en">
All node names to use replication.
Used for startup_method="auto".
</longdesc>
<shortdesc lang="en">node list</shortdesc>
<content type="string" default="${OCF_RESKEY_node_list_default}" />
</parameter>

<parameter name="xlog_note" unique="0" required="0">
<longdesc lang="en">
Temporary file path used for checking xlog.
Used for startup_method="auto".
</longdesc>
<shortdesc lang="en">xlog note</shortdesc>
<content type="string" default="${OCF_RESKEY_xlog_note_default}" />
</parameter>

<parameter name="xlog_check_count" unique="0" required="0">
<longdesc lang="en">
I check xlog location to decide master on monitor operation.
I wait to decide master this times on monitor
after xlog location is not changed.
Used for startup_method="auto".
</longdesc>
<shortdesc lang="en">xlog check count</shortdesc>
<content type="string" default="${OCF_RESKEY_check_count_default}" />
</parameter>

</parameters>

<actions>
<action name="start" timeout="120" />
<action name="stop" timeout="120" />
<action name="status" timeout="60" />
<action name="monitor" depth="0" timeout="30" interval="30"/>
<action name="monitor" depth="0" timeout="30" interval="29" role="Master" />
<action name="promote" timeout="120" />
<action name="demote" timeout="120" />
<action name="notify"   timeout="90" />
<action name="meta-data" timeout="5" />
<action name="validate-all" timeout="5" />
<action name="methods" timeout="5" />
</actions>
</resource-agent>
EOF
}


#
#	Run the given command in the Resource owner environment...
#
runasowner() {
    local quietrun=""
    local loglevel="-err"
    local var

    for var in 1 2
    do
        case "$1" in
            "-q")
                quietrun="-q"
                shift 1;;
            "warn"|"err")
                loglevel="-$1"
                shift 1;;
            *)
                ;;
        esac
    done

    ocf_run $quietrun $loglevel su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; $*"
}

#
#       Shell escape
#
escape_string() {
    echo "$*" | sed -e "s/'/'\\\\''/g"
}


#
# methods: What methods/operations do we support?
#

pgsql_methods() {
  cat <<EOF
	start
	stop
	status
	monitor
	promote
	demote
	notify
	methods
	meta-data
	validate-all
EOF
}


#pgsql_start: Starts PostgreSQL
pgsql_real_start() {
    local rc
    local pgctl_options
    local postgres_options

    if pgsql_status; then
        ocf_log info "PostgreSQL is already running. PID=`cat $PIDFILE`"
        return $OCF_SUCCESS
    fi

    # Remove postmaster.pid if it exists
    rm -f $PIDFILE

    # Remove backup_label if it exists
    if [ -f $BACKUPLABEL ]; then
	ocf_log info "Removing $BACKUPLABEL. The previous backup might have failed."
	rm -f $BACKUPLABEL
    fi

    # Check if we need to create a log file
    if ! check_log_file $OCF_RESKEY_logfile
    then
        ocf_log err "PostgreSQL can't write to the log file: $OCF_RESKEY_logfile"
	return $OCF_ERR_PERM
    fi

    # Check socket directory
    if [ -n "$OCF_RESKEY_socketdir" ]
    then
        check_socket_dir
    fi

    # Set options passed to pg_ctl
    pgctl_options="$OCF_RESKEY_ctl_opt -D $OCF_RESKEY_pgdata -l $OCF_RESKEY_logfile"

    # Set options passed to the PostgreSQL server process
    postgres_options=""
    if [ -n "$OCF_RESKEY_config" ]; then
	postgres_options="$postgres_options -c config_file=${OCF_RESKEY_config}"
    fi
    if [ -n "$OCF_RESKEY_pghost" ]; then
	postgres_options="$postgres_options -h $OCF_RESKEY_pghost"
    fi
    if [ -n "$OCF_RESKEY_start_opt" ]; then
	postgres_options="$postgres_options $OCF_RESKEY_start_opt"
    fi

    # Tack pass-through options onto pg_ctl options
    if [ -n "$postgres_options" ]; then
	pgctl_options="$pgctl_options -o '$postgres_options'"
    fi

    # Invoke pg_ctl
    runasowner "$OCF_RESKEY_pgctl $pgctl_options start"

    if [ $? -eq 0 ]; then
	# Probably started.....
        ocf_log info "PostgreSQL start command sent."
    else
	ocf_log err "Can't start PostgreSQL."
        return $OCF_ERR_GENERIC
    fi

    while :
    do
        pgsql_real_monitor warn
        rc=$?
        if [ $rc -eq $OCF_RUNNING_MASTER -o $rc -eq $OCF_SUCCESS ]; then
            break;
        fi
        sleep 1
	ocf_log debug "PostgreSQL still hasn't started yet. Waiting..."
    done
    ocf_log info "PostgreSQL is started."
    return $rc
}

#pgsql_start:
pgsql_start() {
    if ! is_replication; then
        pgsql_real_start
        return $?
    fi

    if ! rm -f "$REPRESS_MONITOR"; then
        ocf_log err "Can't remove $REPRESS_MONITOR."
        return $OCF_ERR_GENERIC
    fi

    if ! rm -f "${OCF_RESKEY_xlog_note}*"; then
        ocf_log err "Can't remove $OCF_RESKEY_xlog_note.* files"
        return $OCF_ERR_GENERIC
    fi

    if [ -f "$REPRESS_START" ]; then
        ocf_log err "Repressing start file exists."
        show_status "STOP:repressing start file exists"
        return $OCF_ERR_GENERIC
    fi

    if pgsql_status; then
        ocf_log info "PostgreSQL is already running. PID=`cat $PIDFILE`"
        show_status "UNKNOWN:already started"
        pgsql_real_monitor
        return $?
    fi

    show_status "STOP"

    # Use recovery.conf
    if [ "$OCF_RESKEY_startup_method" = "recovery" ]; then
        ocf_log info "use recovery.conf to start"
        if [ ! -f "$RECOVERY_CONF" ]; then
            ocf_log info "recovery.conf doesn't exist, so start PostgreSQL as a primary."

            ocf_log debug "OCF_RESKEY_CRM_meta_notify_master_uname: '$OCF_RESKEY_CRM_meta_notify_master_uname'"
            if [ x != x$OCF_RESKEY_CRM_meta_notify_master_uname ]; then
                ocf_log err "Master already exists. HOST=$OCF_RESKEY_CRM_meta_notify_master_uname"
                show_status "STOP:master already exists"
                return $OCF_ERR_GENERIC
            fi

            if ! touch "$REPRESS_MONITOR"; then
                ocf_log err "Can't create $REPRESS_MONITOR."
                return $OCF_ERR_GENERIC
            fi
            ocf_log info "Monitor operation was repressed. Waiting for promote ... "

            $CRM_MASTER -v $PROMOTE_ME
            show_status "STOP:waiting for promote op"
        else
            ocf_log info "recovery.conf exists, so start PostgreSQL as a hot standby."

            ocf_log debug "OCF_RESKEY_CRM_meta_notify_master_uname: '$OCF_RESKEY_CRM_meta_notify_master_uname'"
            if [ x = x$OCF_RESKEY_CRM_meta_notify_master_uname ]; then
                ocf_log err "Master doesn't exit."
                show_status "STOP:master doesn't exist"
                return $OCF_ERR_GENERIC
            fi

            if ! touch "$REPRESS_START"; then
                ocf_log err "Can't create $REPRESS_START."
                return $OCF_ERR_GENERIC
            fi
            ocf_log info "start op:$REPRESS_START was created"

            pgsql_real_start
            if [ $? -ne $OCF_SUCCESS ]; then
                ocf_log err "PostgreSQL has not started as a hot standby."
                return $OCF_ERR_GENERIC
            fi

            $CRM_MASTER -v $CAN_PROMOTE
            show_status "HS"
        fi
    # Use xlog on start
    elif [ "$OCF_RESKEY_startup_method" = "auto" ]; then
        rm -f ${OCF_RESKEY_xlog_note}.*
        cp $RECOVERY_CONF_BACK $RECOVERY_CONF
        chown $OCF_RESKEY_pgdba $RECOVERY_CONF

        if [ ! -f "$RECOVERY_CONF" ]; then
            ocf_log err "recovery.conf doesn't exist."
            return $OCF_ERR_INSTALLED;
        fi

        ocf_log info "auto start"
        $CRM_MASTER -v $CAN_NOT_PROMOTE

        set_async_mode
        pgsql_real_start
        if [ $? -ne $OCF_SUCCESS ]; then
            ocf_log err "PostgreSQL has not started as a hot standby."
            return $OCF_ERR_GENERIC
        fi
        show_status "HS:not connected"

        # If master is already exist, I will get timeline files and check connection to master.
        if [ x != x$OCF_RESKEY_CRM_meta_notify_master_uname ]; then
            ocf_log info "Master is exist on start op."
            if ! get_timeline_file; then
                return $OCF_ERR_GENERIC
            fi

            show_status "HS:connecting"
            while :
            do
                if is_connect; then
                    break
                fi
                ocf_log info "PostgreSQL still hasn't connected to primary yet. Waiting..."
                sleep 1
            done
            if can_promote; then
                $CRM_MASTER -v $CAN_PROMOTE
                show_status "HS:streaming"
            else
                show_status "HS:not streaming"
            fi
            ocf_log info "PostgreSQL is connected to primary."
        fi
    else
        ocf_log err "startup_method \"$OCF_RESKEY_startup_method\" is invalid."
        return $OCF_ERR_CONFIGURED
    fi

    return $OCF_SUCCESS
}

#
# promote operation
#
pgsql_promote() {
    if ! is_replication; then
        return $OCF_ERR_CONFIGURED
    fi

    # Use recovery.conf
    if [ "$OCF_RESKEY_startup_method" = "recovery" ]; then
        if ! pgsql_status; then
            if [ -f "$REPRESS_START" ]; then
                ocf_log err "Repressing start file exists."
                show_status "STOP:repressing start file exists"
                return $OCF_ERR_GENERIC
            fi

            if ! touch "$REPRESS_START"; then
                ocf_log err "Can't create $REPRESS_START."
                return $OCF_ERR_GENERIC
            fi
            ocf_log info "promote op:$REPRESS_START was created."

            pgsql_real_start
            if [ $? -ne $OCF_RUNNING_MASTER ]; then
                ocf_log err "PostgreSQL has not started as a primary."
                return $OCF_ERR_GENERIC
            fi

            if ! rm -f "$REPRESS_MONITOR"; then
                ocf_log err "Can't remove $REPRESS_MONITOR."
                return $OCF_ERR_GENERIC
            fi
            ocf_log info "Monitor operation was resumed."
            show_status "PRI"
        else
            runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata promote"
            wait_promoted
            $CRM_MASTER -v $PROMOTE_ME
        fi
    # auto start
    elif [ "$OCF_RESKEY_startup_method" = "auto" ]; then
        rm -f ${OCF_RESKEY_xlog_note}.*
        if [ -f $REPRESS_PROMOTE ]; then
            ocf_log warn "${REPRESS_PROMOTE} file is exist"
            return $OCF_ERR_GENERIC
        fi
        runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata promote"
        wait_promoted
        $CRM_MASTER -v $PROMOTE_ME
    else
        ocf_log err "startup_method \"$OCF_RESKEY_startup_method\" is invalid."
        return $OCF_ERR_CONFIGURED
    fi

    return $OCF_SUCCESS
}

#
# demote operation
#
pgsql_demote() {
    local rc
    $CRM_MASTER -v $CAN_NOT_PROMOTE

    if ! pgsql_status
    then
        ocf_log info "PostgreSQL is already stopped."
        show_status "STOP"
        return $OCF_SUCCESS
    fi

    ocf_log info "stopping PostgreSQL on demote"
    pgsql_real_stop
    rc=$?
    if [ $rc -ne $OCF_SUCCESS ]; then
        show_status "UNKNOWN"
        return $rc
    fi

    show_status "STOP"
    set_async_mode
    return $OCF_SUCCESS
}

#pgsql_stop: Stop PostgreSQL
pgsql_real_stop() {
    local rc

    if ! pgsql_status
    then
        #Already stopped
        return $OCF_SUCCESS
    fi

    # Stop PostgreSQL, do not wait for clients to disconnect
    runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata stop -m fast"

    # stop waiting
    count=0
    while [ $count -lt $OCF_RESKEY_stop_escalate ]
    do
        if ! pgsql_status
        then
            #PostgreSQL stopped
            break;
        fi
        count=`expr $count + 1`
        sleep 1
    done

    if pgsql_status
    then
       #PostgreSQL is still up. Use another shutdown mode.
       ocf_log info "PostgreSQL failed to stop after ${OCF_RESKEY_stop_escalate}s using -m fast. Trying -m immediate..."
       runasowner "$OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata stop -m immediate"
    fi

    while :
    do
        pgsql_real_monitor
        rc=$?
        if [ $rc -eq $OCF_NOT_RUNNING ]; then
            # An unnecessary debug log is prevented.
            break;
        fi
	sleep 1
	ocf_log debug "PostgreSQL still hasn't stopped yet. Waiting..."
    done

    # Remove postmaster.pid if it exists
    rm -f $PIDFILE

    return $OCF_SUCCESS
}


#pgsql_stop
pgsql_stop() {
    local rc

    if ! is_replication; then
        pgsql_real_stop
        return $?
    fi

    $CRM_MASTER -v $CAN_NOT_PROMOTE
    delete_xlog_replay_location

    if ! pgsql_status
    then
        ocf_log info "PostgreSQL is already stopped."
        show_status "STOP"
        return $OCF_SUCCESS
    fi

    pgsql_real_stop
    rc=$?
    if [ $rc -ne $OCF_SUCCESS ]; then
        show_status "UNKNOWN"
        return $rc
    fi

    show_status "STOP"
    return $OCF_SUCCESS
}


#
# pgsql_status: is PostgreSQL up?
#

pgsql_status() {
     if [ -f $PIDFILE ]
     then
         PID=`head -n 1 $PIDFILE`
         runasowner "kill -s 0 $PID >/dev/null 2>&1"
         return $?
     fi

     # No PID file
     false
}

#
# pgsql_monitor
#

pgsql_real_monitor() {
    local rc
    local loglevel
    local psql_options
    local output

    # Set the log level of the error message
    loglevel=${1:-err}

    if ! pgsql_status
    then
	ocf_log info "PostgreSQL is down"
	return $OCF_NOT_RUNNING
    fi

    if [ -n "$OCF_RESKEY_monitor_user" ]; then
        PGUSER=$OCF_RESKEY_monitor_user; export PGUSER
        PGPASSWORD=$OCF_RESKEY_monitor_password; export PGPASSWORD
        psql_options="-p $OCF_RESKEY_pgport $OCF_RESKEY_pgdb"
    else
        psql_options="-p $OCF_RESKEY_pgport -U $OCF_RESKEY_pgdba $OCF_RESKEY_pgdb"
    fi

    if [ -n "$OCF_RESKEY_pghost" ]; then
	psql_options="$psql_options -h $OCF_RESKEY_pghost"
    else
       if [ -n "$OCF_RESKEY_socketdir" ]; then
           psql_options="$psql_options -h $OCF_RESKEY_socketdir"
       fi
    fi

    if ! is_replication; then
        OCF_RESKEY_monitor_sql=`escape_string "$OCF_RESKEY_monitor_sql"`
        runasowner -q $loglevel "$OCF_RESKEY_psql $psql_options -c '$OCF_RESKEY_monitor_sql'"

        rc=$?
        if [ $rc -ne  0 ]; then
        ocf_log $loglevel "PostgreSQL $OCF_RESKEY_pgdb isn't running"
            if [ $rc -eq 1 ]; then
                ocf_log err "Fatal error (out of memory, file not found, etc.) occurred while executing the psql command."
            elif [ $rc -eq 2 ]; then
                ocf_log $loglevel "Connection error (connection to the server went bad and the session was not interactive) occurred while executing the psql command."
            elif [ $rc -eq 3 ]; then
                ocf_log err "Script error (the variable ON_ERROR_STOP was set) occurred while executing the psql command."
            fi
        return $OCF_ERR_GENERIC
        fi
    else
        output=`su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; $OCF_RESKEY_psql $psql_options -Atc '$CHECK_MS_SQL'" 2>&1`
        rc=$?
        case "$output" in
            f)  ocf_log debug "PostgreSQL is running as a primary."
                return $OCF_RUNNING_MASTER;;

            t)  ocf_log debug "PostgreSQL is running as a hot standby."
                return $OCF_SUCCESS;;

            *)  ocf_log err "Fatal error in '$CHECK_MS_SQL': $output"
                return $OCF_ERR_GENERIC;;
        esac
    fi

    return $OCF_SUCCESS
}

pgsql_monitor() {
    local rc
    local masters
    local rep_state
    local my_master_score
    local rsc
    local node
    local max_clone

    if ! is_replication; then
        pgsql_real_monitor
        return $?
    fi

    if [ "$OCF_RESKEY_startup_method" = "recovery" ]; then
        if ! ocf_is_probe; then
            if [ -f $REPRESS_MONITOR ]; then
                ocf_log info "Waiting for promote ... "
                show_status "STOP:waiting for promote op"
                return $OCF_SUCCESS
            fi
        fi

        pgsql_real_monitor
        rc=$?
        if ocf_is_probe; then
            if [ $rc -eq $OCF_RUNNING_MASTER -o $rc -eq $OCF_SUCCESS ]; then
                ocf_log warn "probe: PostgreSQL has started before the resource agent starts. PID=`cat $PIDFILE`"

                if ! rm -f $REPRESS_MONITOR; then
                    ocf_log err "Can't remove $REPRESS_MONITOR."
                    return $OCF_ERR_GENERIC
                fi

                if ! touch $REPRESS_START; then
                    ocf_log err "Can't create $REPRESS_START."
                    return $OCF_ERR_GENERIC
                fi
                ocf_log info "probe:$REPRESS_START was created."

                if [ $rc -eq $OCF_RUNNING_MASTER ]; then
                    ocf_log info "probe: PostgreSQL is running as a primary."
                    $CRM_MASTER -v $PROMOTE_ME
                    show_status "PRI"
                else
                    ocf_log info "probe: PostgreSQL is running as a hot standby."
                    $CRM_MASTER -v $CAN_PROMOTE
                    show_status "HS"
                fi
            fi
        fi

        if ! ocf_is_probe; then
            if [ $rc -eq $OCF_NOT_RUNNING ]; then
                show_status "STOP:with errors"
            fi
            if [ $rc -eq $OCF_ERR_GENERIC ]; then
                show_status "UNKNOWN:with errors"
            fi
        fi
    # auto on monitor
    elif [ "$OCF_RESKEY_startup_method" = "auto" ]; then
        pgsql_real_monitor
        rc=$?

        # If I am Master
        if [ "$rc" = "$OCF_RUNNING_MASTER" ]; then
            if ocf_is_probe; then
                ocf_log warn "PostgreSQL is already running as a primary on probe"
                $CRM_MASTER -v $CAN_PROMOTE
                show_status "PRI:async"
                rm -f $REPRESS_PROMOTE
                return $rc
            fi

            # check slave's connection and select replication mode
            if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                check_replication_state
                rep_state=$?
                if [ "$rep_state" = $STATE_STREAMING_SYNC ] ; then
                    ocf_log debug "Primary is already sync mode"
                    show_status "PRI:sync"
                elif [ "$rep_state" = $STATE_STREAMING_ASYNC ] ; then
                    if set_sync_mode; then
                        reload_conf
                        show_status "PRI:sync"
                    fi
                else
                    # if I am already sync mode
                    if is_sync_mode; then
                        rsc=`echo $OCF_RESOURCE_INSTANCE | cut -d ":" -f 1`
                        # bug .... I can't get start_uname correctly.
                        # ocf_log err "HS is disconnected. rsc=$rsc node=$OCF_RESKEY_CRM_meta_notify_start_uname clone_max=$OCF_RESKEY_CRM_meta_clone_max"
                        #for node in $OCF_RESKEY_CRM_meta_notify_start_uname; do

                        ocf_log err "HS is disconnected. rsc=$rsc node=$OCF_RESKEY_node_list clone_max=$OCF_RESKEY_CRM_meta_clone_max"
                        for node in $OCF_RESKEY_node_list; do
                            if [ "$node" = "$HA_CURHOST" ];then
                                continue
                            fi
                            ocf_log info "Failing $rsc on $node. Probably slave or LAN is dead."
                            instance=0
                            while :
                            do
                                if [ "$instance" -ge "$OCF_RESKEY_CRM_meta_clone_max" ]; then
                                    break
                                fi
                                if [ x"$node" != "x" ];then
                                    $CRM_FAILCOUNT -r ${rsc}:${instance} -U $node -v INFINITY
                                fi
                                instance=`expr $instance + 1`
                            done
                        done
                    fi
                    if set_async_mode; then
                        reload_conf
                        show_status "PRI:async"
                    fi
                fi
            fi
        fi

        if [ "$rc" != $OCF_SUCCESS ]; then
            return $rc
        fi

        # If I am Slave

        # hmm... I can't get master name on monitor. It's bug ...
        # http://developerbugs.linux-foundation.org/show_bug.cgi?id=2607
        # if [ x != x$OCF_RESKEY_CRM_meta_notify_master_uname ]; then

        masters=`crm_mon -1 | grep "Masters: \["`
        if [ "x$masters" != "x" ]; then

            if ocf_is_probe; then
                ocf_log warn "PostgreSQL is already running as a hot standby on probe"
                if ! is_connect; then
                    ocf_log info "PostgreSQL still hasn't connected to primary."
                    return $OCF_ERR_GENERIC
                fi
                ocf_log info "PostgreSQL is connected to primary."
                $CRM_MASTER -v $CAN_NOT_PROMOTE
                show_status "HS:not streaming"
            fi

            my_master_score=`crm_attribute -N ${HA_CURHOST} -n master-${OCF_RESOURCE_INSTANCE} -l reboot -G -q`
            if can_promote; then
                if [ "${my_master_score}" -le "0" ] || [ "${my_master_score}" = "-INFINITY" ]; then  
                    ocf_log info "PostgreSQL is changed to STREAMING mode."
                    $CRM_MASTER -v $CAN_PROMOTE
                fi
                show_status "HS:streaming"
            else
                if ! is_connect; then
                    ocf_log info "PostgreSQL is disconnected to primary."
                    show_status "HS:not connected"
                else
                    if [ "${my_master_score}" -gt "0" ]; then  
                        show_status "HS:not streaming"
                    fi
                fi
            fi

            return $rc
        # if master doesn't exist, we check xlog.
        else
            ocf_log info "master is not exist."
            show_status "HS:not connected"
            is_master_right
            if [ "$?" = "0" ]; then
                $CRM_MASTER -v $PROMOTE_ME
                rm -f ${OCF_RESKEY_xlog_note}.$count
            fi
        fi
    else
        ocf_log err "startup_method \"$OCF_RESKEY_startup_method\" is invalid."
        return $OCF_ERR_CONFIGURED
    fi

    return $rc
}

wait_promoted() {
    local rc
    while :
    do
        pgsql_real_monitor warn
        rc=$?
        if [ $rc -eq $OCF_RUNNING_MASTER ]; then
            break;
        fi
        sleep 1
        ocf_log debug "PostgreSQL still hasn't promoted yet. Waiting..."
    done
    ocf_log info "PostgreSQL is promoted."
    show_status "PRI:async"
    return 0
}

is_master_right() {
    local rc
    local old
    local new
    local output
    local node
    local mylocation

    ocf_log debug "checking right of master"

    if [ -f $REPRESS_PROMOTE ]; then
        ocf_log warn "$REPRESS_PROMOTE file is exist."
        return 1
    fi

    old=1
    new=1
    for count in `seq $OCF_RESKEY_xlog_check_count`; do
       if [ -f ${OCF_RESKEY_xlog_note}.$count ]; then
           old=$count
           continue
       fi
       new=$count
       break
    done

    show_xlog_replay_location
    if [ "$?" != "0" ]; then
        ocf_log err "show_xlog_replay_location failed"
        $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
    fi

    for node in ${OCF_RESKEY_CRM_meta_notify_start_uname}; do
        output=`eval get_xlog_replay_location_by_node ${node}`
        rc=$?
        if [ "$rc" != "0" ]; then
	    ocf_log warn "can't get xlog replay location:$output:${node}"
            continue
        else
	    ocf_log info "xlog replay location is $output : $node"
            echo "${node} ${output}" >> $OCF_RESKEY_xlog_note.$new
	    if [ ${node} = ${HA_CURHOST} ]; then
                mylocation=${output}
            fi
        fi
    done

    if [ "$old" = "$new" ]; then
        return 1
    fi

    if [ "$new" = "$OCF_RESKEY_xlog_check_count" ]; then
       newestNode=`cat $OCF_RESKEY_xlog_note.$new | sort -t " " -k 2,3 -r | head -1 | cut -d " " -f 1`
       newestXlog=`cat $OCF_RESKEY_xlog_note.$new | sort -t " " -k 2,3 -r | head -1 | cut -d " " -f 2`
       if [ "$newestNode" = "$HA_CURHOST" ]; then
           ocf_log info "I have master right."
           return 0
       fi
       if [ "${newestXlog}" = "${mylocation}" ]; then
           ocf_log info "I have master right."
           return 0
       fi
       ocf_log info "I have no master right."
       if ! touch $REPRESS_PROMOTE; then
            ocf_log err "can't create $REPRESS_PROMOTE"
            return 1
       fi
       ocf_log info "$REPRESS_PROMOTE file was created"
    else
        oldfile=`cat ${OCF_RESKEY_xlog_note}.$old`
        newfile=`cat ${OCF_RESKEY_xlog_note}.$new`
        if [ "$oldfile" != "$newfile" ]; then
            mv -f ${OCF_RESKEY_xlog_note}.$new ${OCF_RESKEY_xlog_note}.1

            # reset counter
            for count in `seq 2 $OCF_RESKEY_xlog_check_count`; do
            rm -f ${OCF_RESKEY_xlog_note}.$count
            done
        fi
    fi
    return 1
}

# for checking timeline.
is_connect() {
    local rc
    local output
    local connectOK=1

    ocf_log debug "checking connection"

    get_master_ip force
    if [ "$?" = "0" ]; then
        output=`$OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h $MASTER_IP -p $OCF_RESKEY_pgport -Atc "$CHECK_REPLICATION_CLIENT_SQL" 2>&1`
        rc=$?
        if [ "$rc" != "0" ]; then
            ocf_log info "psql error $MASTER_IP rc=$rc"
        else
            if is_myip "$output"; then
                ocf_log debug "connection OK"
                return 0
            fi
        fi
    fi

    ocf_log debug "connection NG"
    return 1
}

pgsql_post_promote() {
    local IS_CONNECT_TIMEOUT

    if [ "$OCF_RESKEY_startup_method" = "auto" ]; then
        ocf_log info "post-promote called.(master is ${OCF_RESKEY_CRM_meta_notify_promote_uname})"
	delete_xlog_replay_location

        if [ "${OCF_RESKEY_CRM_meta_notify_promote_uname}" = "${HA_CURHOST} " ]; then
            return $OCF_SUCCESS
        fi

        IS_CONNECT_TIMEOUT=`expr ${OCF_RESKEY_CRM_meta_timeout} / 1000 - 15`
        if [ "$IS_CONNECT_TIMEOUT" -lt "2" ]; then
            ocf_log err "notify timeout is too small : < 18"
            $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
        fi
        rm -f ${OCF_RESKEY_xlog_note}.*
        if ! get_timeline_file; then
            $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
            return $OCF_ERR_GENERIC
        fi

        show_status "HS:connecting"
        while :
        do
            IS_CONNECT_TIMEOUT=`expr $IS_CONNECT_TIMEOUT - 1`
            if [ "$IS_CONNECT_TIMEOUT" = "0" ]; then
                ocf_log err "Can not connect to primary on post_promote."
                show_status "HS:not connected"
                $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
                return $OCF_ERR_GENERIC
            fi

            if is_connect; then
                ocf_log info "PostgreSQL is connected to primary."
                # TODO : I want to check xlog location difference
                if can_promote; then
                    $CRM_MASTER -v $CAN_PROMOTE
                    show_status "HS:streaming"
                else
                    show_status "HS:not streaming"
                fi
                break
            fi
            ocf_log info "PostgreSQL still hasn't connected to master yet. Waiting... $IS_CONNECT_TIMEOUT"
            sleep 1
        done
    fi
    return $OCF_SUCCESS
}

pgsql_post_demote() {
    local IS_CONNECT_TIMEOUT
    local my_fail_count

    if [ "$OCF_RESKEY_startup_method" = "auto" ]; then
        ocf_log info "post-demote called.(master is ${OCF_RESKEY_CRM_meta_notify_demote_uname})"

        IS_CONNECT_TIMEOUT=`expr ${OCF_RESKEY_CRM_meta_timeout} / 1000 - 15`
        if [ "$IS_CONNECT_TIMEOUT" -lt "2" ]; then
            ocf_log err "notify timeout is too small : < 18"
            $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
        fi

        if [ "${OCF_RESKEY_CRM_meta_notify_demote_uname}" = "${HA_CURHOST} " ]; then
            if [ -f $REPRESS_PROMOTE ]; then
                ocf_log warn "${REPRESS_PROMOTE} file is exist so I don't restart"
                return $OCF_SUCCESS
            fi

            my_fail_count=`crm resource failcount ${OCF_RESOURCE_INSTANCE} show ${OCF_RESKEY_CRM_meta_notify_demote_uname} | sed -e "s/.*value=//g"`
            if [ "$my_fail_count" != "0" ]; then
                ocf_log info "My faicount=${my_fail_count}, so I don't restart on post_demote"
                return $OCF_ERR_GENERIC
            fi

            rm -f ${OCF_RESKEY_xlog_note}.*
            cp $RECOVERY_CONF_BACK $RECOVERY_CONF
            chown $OCF_RESKEY_pgdba $RECOVERY_CONF
            pgsql_real_start
            if [ $? -ne $OCF_SUCCESS ]; then
                ocf_log err "PostgreSQL has not started as a hot standby."
                return $OCF_ERR_GENERIC
            fi
            show_status "HS:not connected"

            if [ x"${OCF_RESKEY_CRM_meta_notify_master_uname}" != "x" ]; then
                if ! get_timeline_file; then
                    return $OCF_ERR_GENERIC
                    $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
                fi

                show_status "HS:connecting"
                while :
                do
                    IS_CONNECT_TIMEOUT=`expr $IS_CONNECT_TIMEOUT - 1`
                    if [ "$IS_CONNECT_TIMEOUT" = "0" ]; then
                        ocf_log err "Can not connect to primary on post_demote."
                        $CRM_FAILCOUNT -r $OCF_RESOURCE_INSTANCE -U $HA_CURHOST -v INFINITY
                        return $OCF_ERR_GENERIC
                    fi

                    if is_connect; then
                        ocf_log info "PostgreSQL is connected to primary."
                        if can_promote; then
                            $CRM_MASTER -v $CAN_PROMOTE
                            show_status "HS:streaming"
                        else
                            show_status "HS:not streaming"
                        fi
                        break
                    fi
                    ocf_log info "PostgreSQL still hasn't connected to master yet. Waiting... $IS_CONNECT_TIMEOUT"
                    sleep 1
                done
            fi

            return $OCF_SUCCESS
        else
            show_status "HS:not connected"
        fi
    fi
    return $OCF_SUCCESS
}

pgsql_notify() {
    local type="$OCF_RESKEY_CRM_meta_notify_type"
    local op="$OCF_RESKEY_CRM_meta_notify_operation"

    ocf_log debug "notify: $type for $op"

    case $type in
        post)
            case $op in
                promote)
                    pgsql_post_promote
                    return $?
                    ;;
                demote)
                    pgsql_post_demote
                    return $?
                    ;;
            esac
            ;;
    esac

    return $OCF_SUCCESS
}


check_binary2() {
    if ! have_binary "$1"; then
        ocf_log err "Setup problem: couldn't find command: $1"
        return 1
    fi
    return 0
}

# Validate most critical parameters
pgsql_validate_all() {
    if ! check_binary2 "$OCF_RESKEY_pgctl" || 
       ! check_binary2 "$OCF_RESKEY_psql"; then
        return $OCF_ERR_INSTALLED
    fi

    if [ -n "$OCF_RESKEY_config" -a ! -f "$OCF_RESKEY_config" ]; then
        ocf_log err "the configuration file $OCF_RESKEY_config doesn't exist"
        return $OCF_ERR_INSTALLED
    fi

    getent passwd $OCF_RESKEY_pgdba >/dev/null 2>&1
    if [ ! $? -eq 0 ]; then
        ocf_log err "User $OCF_RESKEY_pgdba doesn't exit";
        return $OCF_ERR_INSTALLED;
    fi

    if ! runasowner "test -w $OCF_RESKEY_pgdata"; then
        ocf_log err "Directory $OCF_RESKEY_pgdata is not writable by $OCF_RESKEY_pgdba"
        exit $OCF_ERR_PERM;
    fi

    if [ -n "$OCF_RESKEY_monitor_user" -a ! -n "$OCF_RESKEY_monitor_password" ]
    then
        ocf_log err "monitor password can't be empty"
        return $OCF_ERR_CONFIGURED
    fi

    if [ ! -n "$OCF_RESKEY_monitor_user" -a -n "$OCF_RESKEY_monitor_password" ]
    then
        ocf_log err "monitor_user has to be set if monitor_password is set"
        return $OCF_ERR_CONFIGURED
    fi

    if is_replication; then
        if [ ! -d "$OCF_RESKEY_tmpdir" ]; then
            ocf_log err "$OCF_RESKEY_tmpdir directory doesn't exist"
            return $OCF_ERR_INSTALLED;
        fi

        if [ "$OCF_RESKEY_startup_method" = "auto" ]; then
            if [ -z "$OCF_RESKEY_ip_list" ]; then
                ocf_log err "ip_list is null"
                return $OCF_ERR_CONFIGURED
            fi
            if ! check_binary2 "$OCF_RESKEY_pgctldata" ||
               ! check_binary2 "$CRM_FAILCOUNT"; then
                return $OCF_ERR_INSTALLED
            fi
        fi
        if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
            if [ ! -n "$OCF_RESKEY_rep_mode_conf" ]; then
                return $OCF_ERR_CONFIGURED
            fi
            touch $OCF_RESKEY_rep_mode_conf
            if [ "$?" != "0" ]; then
                ocf_log err "Can't create $OCF_RESKEY_rep_mode_conf"
                return $OCF_ERR_INSTALLED
            fi
        fi
    fi

    return $OCF_SUCCESS
}


#
# Check if we need to create a log file
#

check_log_file() {
    if [ ! -f "$1" ]
    then
        touch $1 > /dev/null 2>&1
        chown $OCF_RESKEY_pgdba:`getent passwd $OCF_RESKEY_pgdba | cut -d ":" -f 4` $1
    fi

    #Check if $OCF_RESKEY_pgdba can write to the log file
    if ! runasowner "test -w $1"
    then
        return 1
    fi

    return 0
}

#
# Check socket directory
#
check_socket_dir() {
    if [ ! -d "$OCF_RESKEY_socketdir" ]; then
        if ! mkdir "$OCF_RESKEY_socketdir"; then
            ocf_log err "Cannot create directory $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi

        if ! chown $OCF_RESKEY_pgdba:`getent passwd \
             $OCF_RESKEY_pgdba | cut -d ":" -f 4` "$OCF_RESKEY_socketdir" 
        then
            ocf_log err "Cannot change ownership for $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi

        if ! chmod 2775 "$OCF_RESKEY_socketdir"; then
            ocf_log err "Cannot change permissions for $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi
    else
        if ! runasowner "touch $OCF_RESKEY_socketdir/test.$$"; then
            ocf_log err "$OCF_RESKEY_pgdba cannot create files in $OCF_RESKEY_socketdir"
            exit $OCF_ERR_PERM
        fi
        rm $OCF_RESKEY_socketdir/test.$$
    fi
}

is_replication() {
    if [ "$OCF_RESKEY_rep_mode" != "none" ]; then
        return 0
    fi
    return 1
}

show_status() {
    if [ "$OCF_RESKEY_show_status" = "yes" ]; then
        $ATTRD_UPDATER -n $PGSQL_STATUS_NAME -v "$1"
    fi
}

show_xlog_replay_location() {
    local output
    local rc
    local output1
    local output2
    local log1
    local log2

    output=`su ${OCF_RESKEY_pgdba} -c "cd ${OCF_RESKEY_pgdata}; ${OCF_RESKEY_psql} -U ${OCF_RESKEY_pgdba} -p ${OCF_RESKEY_pgport} -Atc \"${CHECK_XLOG_REPLAY_LOC_SQL}\""`
    rc=$?
    if [ "$rc" != "0" ]; then
        ocf_log err "can not get xlog replay location"
        return $rc
    fi

    output1=`echo "${output}" | cut -d "/" -f 1`
    output2=`echo "${output}" | cut -d "/" -f 2`
    log1=`printf "%08s\n" ${output1} | sed "s/ /0/g"`
    log2=`printf "%08s\n" ${output2} | sed "s/ /0/g"`
    ocf_log info "my xlog replay location : ${log1}/${log2}"
    echo "${log1}${log2}"

    crm_attribute --type nodes -N `uname -n` --attr-name "${PGSQL_XLOG_REPLAY_LOC_NAME}" --attr-value "${log1}${log2}" -l reboot
    return $?
}

delete_xlog_replay_location() {
    crm_attribute --type nodes -N `uname -n` --attr-name "${PGSQL_XLOG_REPLAY_LOC_NAME}" -D -l reboot
    return $?
}

get_xlog_replay_location_by_node() {
    crm_attribute --type nodes -N $1 --attr-name "${PGSQL_XLOG_REPLAY_LOC_NAME}" -G -q -l reboot
    return $?
}

check_ping() {
    ping -c 2 -W 3 $1 > /dev/null
    return $?
}

is_myip() {
    $IP2UTIL -f inet addr show | grep "inet $1/" > /dev/null
    return $?
}

is_master() {
    local output
    local rc

    if ! check_ping "$1"; then
        return 1
    fi

    output=`$OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h $1 -p $OCF_RESKEY_pgport -Atc "$CHECK_MS_SQL" 2>&1`
    rc=$?
    if [ "$rc" != "0" ]; then
        return 1
    else
        if [ "$output" = "f" ]; then
            return 0
        fi
    fi

    return 1
}

get_master_ip() {
    if [ "$1" != "force" ]; then
        if [ "${MASTER_IP}" = "none" ]; then
            return 0
        fi
    fi

    if [ "${MASTER_IP}" = "null" ]; then
        for ip in $OCF_RESKEY_ip_list; do
            if is_master $ip; then
                MASTER_IP=${ip}
                ocf_log debug "master ip is ${MASTER_IP}."
            fi
            if [ "${MY_IP}" != "null" ]; then
                if is_myip $ip; then
                    MY_IP=${ip}
                    ocf_log debug "my ip is ${MY_IP}."
                fi
            fi
        done
    fi

    if [ "${MASTER_IP}" = "null" ]; then
        ocf_log err "Can not connect to primary."
        MASTER_IP="none"
        return 1
    else
        return 0
    fi
}

get_my_ip() {
    if [ "${MY_IP}" = "null" ]; then
        for ip in $OCF_RESKEY_ip_list; do
            if is_myip $ip; then
                MY_IP=${ip}
                ocf_log debug "my ip is ${MY_IP}."
            fi
        done
    fi
    if [ "${MY_IP}" = "null" ]; then
        ocf_log err "can't find my ip."
        return 1
    else
        return 0
    fi
}

get_timeline_file() {
    local filesize
    local TIMELINE="-1"
    local TIMELINE_HEX="-1"
    TIMELINE=`$OCF_RESKEY_pgctldata $OCF_RESKEY_pgdata | grep TimeLineID | sed "s/ //g" | cut -d ":" -f 2`
    ocf_log info "My timeline id is $TIMELINE(decimal)"

    get_master_ip
    if [ $? = "0" ]; then
        TIMELINE_HEX=`perl -e "\\$num = \"$TIMELINE\"; printf \"\%08X\",\\$num"`
        while :
        do
            # increment timeline ID
            TIMELINE_HEX=`perl -e "\\$num = hex \"${TIMELINE_HEX}\"; printf \"\%08X\",++\\$num"`
            ocf_log info "getting timeline file ${TIMELINE_HEX}.history"

            # get timeline id file size
            filesize=`$OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h $MASTER_IP -p $OCF_RESKEY_pgport -Atc "SELECT pg_stat_file('pg_xlog/${TIMELINE_HEX}.history')" 2>/dev/null`
            if [ $? != "0" ]; then
                 ocf_log info "timeline file ${TIMELINE_HEX}.history is not exist"
                 break
            fi
            filesize=`echo $filesize | cut -d "," -f 1 | cut -d "(" -f 2 2>&1`
            ocf_log info "${TIMELINE_HEX}.history size $filesize"

            # get timeline id file
            su $OCF_RESKEY_pgdba -c "cd $OCF_RESKEY_pgdata; $OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h $MASTER_IP -p $OCF_RESKEY_pgport -Atc \"SELECT pg_read_file('pg_xlog/${TIMELINE_HEX}.history', 0, $filesize)\" > $OCF_RESKEY_pgdata/pg_xlog/${TIMELINE_HEX}.history 2>&1"
            if [ $? != 0 ]; then
                 ocf_log err "timeline file ${TIMELINE_HEX} is exist but I can't get."
                 return 1
            fi
        done
        return 0
    fi
    return 1
}

# This needs be called by Slave
# If rep_mode is async, we can promote when state is "STREAMING"
# If rep_mode is sync, we can promote when state is "STREAMING" and sync_state is "SYNC"
can_promote() {
    local rc
    local output
    local my_hostname
    local state
    local sync_state

    get_master_ip
    if [ "$?" = "0" ]; then
        my_hostname=`uname -n`
        output=`$OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h $MASTER_IP -p $OCF_RESKEY_pgport -Atc "$CHECK_REPLICATION_STATE_SQL where application_name='$my_hostname';" 2>&1`
        rc=$?
        if [ "$rc" != "0" ]; then
            ocf_log info "psql error $ip rc=$rc"
        else
            state=`echo $output | cut -d "|" -f 1`
            sync_state=`echo $output | cut -d "|" -f 2`
            if [ "$state" = "STREAMING" ]; then
                ocf_log debug "I am STREAMING mode"
                if [ "$OCF_RESKEY_rep_mode" = "sync" ]; then
                    if [ "$sync_state" = "SYNC" ]; then
                        ocf_log debug "I am STREAMING mode and syncing"
                        rm -f $REPRESS_PROMOTE
                        return 0
                    else
                        ocf_log info "I am STREAMING mode but not syncing"
                        if ! touch $REPRESS_PROMOTE; then
                            ocf_log err "can't create $REPRESS_PROMOTE"
                        fi
                        return 1
                    fi
                fi
                return 0
            else
                ocf_log info "I am not STREAMING mode : $output"
            fi
        fi
    fi
    return 1
}

# This needs be called by Master when rep_mode=sync
check_replication_state() {
    local rc
    local output
    local state
    local sync_state

    get_my_ip
    get_master_ip

    if [ "$?" = "0" ]; then
        output=`$OCF_RESKEY_psql -U $OCF_RESKEY_pgdba -h localhost -p $OCF_RESKEY_pgport -Atc "$CHECK_REPLICATION_STATE_SQL;" 2>&1`
        rc=$?
        if [ "$rc" != "0" ]; then
            ocf_log info "psql error $ip rc=$rc"
        elif [ ! -n "$output" ]; then
            ocf_log info "There is no HS"
            return $STATE_INVALID
        else
            state=`echo $output | cut -d "|" -f 1`
            sync_state=`echo $output | cut -d "|" -f 2`
            if [ "$state" = "STREAMING" ]; then
                ocf_log debug "HS is STREAMING mode"
                if [ "$sync_state" = "ASYNC" ]; then
                    return $STATE_STREAMING_ASYNC
                fi
                if [ "$sync_state" = "SYNC" ]; then
                    return $STATE_STREAMING_SYNC
                fi
                return $STATE_INVALID
            else
                ocf_log info "HS is not STREAMING mode : $output"
                if [ "$sync_state" = "ASYNC" ]; then
                    return $STATE_NOT_STREAMING_ASYNC
                fi
                if [ "$sync_state" = "SYNC" ]; then
                    return $STATE_NOT_STREAMING_SYNC
                fi
                return $STATE_INVALID
            fi
        fi
    fi
    return $STATE_INVALID
}


set_async_mode() {
    if [ "$OCF_RESKEY_rep_mode" != "sync" ]; then
        return 1
    fi

    grep "synchronous_standby_names" $OCF_RESKEY_rep_mode_conf > /dev/null 2>&1
    if [ "$?" != "0" ]; then
        ocf_log debug "Already async mode"
        return 2
    fi

    ocf_log info "set async mode"
    echo "" > "$OCF_RESKEY_rep_mode_conf"
}

set_sync_mode() {
    if [ "$OCF_RESKEY_rep_mode" != "sync" ]; then
        ocf_log info "Can't change sync mode. rep_mode is $OCF_RESKEY_rep_mode"
        return 1
    fi

    grep "synchronous_standby_names" $OCF_RESKEY_rep_mode_conf > /dev/null 2>&1
    if [ "$?" = "0" ]; then
        ocf_log debug "Already sync mode"
        return 2
    fi

    echo "synchronous_standby_names = '*'" > "$OCF_RESKEY_rep_mode_conf"
    ocf_log info "set sync mode"
    return 0
}

is_sync_mode() {
    if [ "$OCF_RESKEY_rep_mode" != "sync" ]; then
        return 0
    fi
    grep "synchronous_standby_names" $OCF_RESKEY_rep_mode_conf > /dev/null 2>&1
    if [ "$?" = "0" ]; then
        return 0
    fi
    return 1
}

reload_conf() {
    # Set options passed to pg_ctl
    pgctl_options="$OCF_RESKEY_ctl_opt -D $OCF_RESKEY_pgdata -l $OCF_RESKEY_logfile"

    # Set options passed to the PostgreSQL server process
    postgres_options=""
    if [ -n "$OCF_RESKEY_config" ]; then
	postgres_options="$postgres_options -c config_file=${OCF_RESKEY_config}"
    fi
    if [ -n "$OCF_RESKEY_pghost" ]; then
	postgres_options="$postgres_options -h $OCF_RESKEY_pghost"
    fi
    if [ -n "$OCF_RESKEY_start_opt" ]; then
	postgres_options="$postgres_options $OCF_RESKEY_start_opt"
    fi

    # Tack pass-through options onto pg_ctl options
    if [ -n "$postgres_options" ]; then
	pgctl_options="$pgctl_options -o '$postgres_options'"
    fi

    # Invoke pg_ctl
    runasowner "$OCF_RESKEY_pgctl $pgctl_options reload"
    if [ $? -eq 0 ]; then
        ocf_log info "Reload configuration file."
    else
	ocf_log err "Can't reload configuration file."
        return 1
    fi

    return 0
}

#
#   'main' starts here...
#


if [ $# -ne 1 ]
then
    usage
    exit $OCF_ERR_GENERIC
fi


PIDFILE=${OCF_RESKEY_pgdata}/postmaster.pid
BACKUPLABEL=${OCF_RESKEY_pgdata}/backup_label

RECOVERY_CONF=${OCF_RESKEY_pgdata}/recovery.conf
RECOVERY_CONF_BACK=${OCF_RESKEY_recovery_conf}
REPRESS_MONITOR=${OCF_RESKEY_tmpdir}/PGSQL.${OCF_RESKEY_pgport}.repress_monitor
REPRESS_START=${OCF_RESKEY_tmpdir}/PGSQL.${OCF_RESKEY_pgport}.repress_start
REPRESS_PROMOTE=${OCF_RESKEY_tmpdir}/PGSQL.${OCF_RESKEY_pgport}.repress_promote
CRM_MASTER="${HA_SBIN_DIR}/crm_master -l reboot"
CAN_NOT_PROMOTE="-INFINITY"
CAN_PROMOTE="100"
PROMOTE_ME="1000"
CHECK_MS_SQL="select pg_is_in_recovery();"
CHECK_XLOG_REPLAY_LOC_SQL="select pg_last_xlog_replay_location();"
CHECK_REPLICATION_CLIENT_SQL="SELECT client_addr from pg_stat_replication;"
CHECK_REPLICATION_STATE_SQL="SELECT state,sync_state from pg_stat_replication"
ATTRD_UPDATER="${HA_SBIN_DIR}/attrd_updater -q -d 0"
PGSQL_STATUS_NAME="pgsql-status"
PGSQL_XLOG_REPLAY_LOC_NAME="pgsql-xlog-replay-loc"
CRM_FAILCOUNT="${HA_SBIN_DIR}/crm_failcount"
MASTER_IP="null"
MY_IP="null"

STATE_STREAMING_ASYNC="1"
STATE_STREAMING_SYNC="2"
STATE_NOT_STREAMING_ASYNC="3"
STATE_NOT_STREAMING_SYNC="4"
STATE_INVALID="5"

case "$1" in
    methods)    pgsql_methods
                exit $?;;

    meta-data)  meta_data
                exit $OCF_SUCCESS;;
esac

# $OCF_RESKEY_pgdata has to be initialized at this momemnt
: ${OCF_RESKEY_socketdir=`get_pgsql_param unix_socket_directory`}

pgsql_validate_all
rc=$?

[ "$1" == "validate-all" ] && exit $rc

if [ $rc -ne 0 ]
then
    case "$1" in
        stop)    exit $OCF_SUCCESS;;
        monitor) exit $OCF_NOT_RUNNING;;
        status)  exit $OCF_NOT_RUNNING;;
        *)       exit $rc;;
    esac
fi

US=`id -u -n`

if [ $US != root -a $US != $OCF_RESKEY_pgdba ]
then
    ocf_log err "$0 must be run as root or $OCF_RESKEY_pgdba"
    exit $OCF_ERR_GENERIC
fi

# What kind of method was invoked?
case "$1" in
    status)     if pgsql_status
                then
                    ocf_log info "PostgreSQL is up"
                    exit $OCF_SUCCESS
                else
                    ocf_log info "PostgreSQL is down"
                    exit $OCF_NOT_RUNNING
                fi;;

    monitor)    pgsql_monitor
                exit $?;;

    start)      pgsql_start
                exit $?;;

    promote)    pgsql_promote
                exit $?;;

    demote)     pgsql_demote
                exit $?;;

    notify)     pgsql_notify
                exit $?;;

    stop)       pgsql_stop
                exit $?;;
    *)
                exit $OCF_ERR_UNIMPLEMENTED;;
esac
